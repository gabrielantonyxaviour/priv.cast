{
  "noir_version": "0.23.0+5be9f9d7e2f39ca228df10e5a530474af0331704",
  "hash": 522587613897474950,
  "abi": {
    "parameters": [
      {
        "name": "pub_key_x",
        "type": {
          "kind": "array",
          "length": 32,
          "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
        },
        "visibility": "private"
      },
      {
        "name": "pub_key_y",
        "type": {
          "kind": "array",
          "length": 32,
          "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
        },
        "visibility": "private"
      },
      {
        "name": "signature",
        "type": {
          "kind": "array",
          "length": 64,
          "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
        },
        "visibility": "private"
      },
      {
        "name": "hashed_message",
        "type": {
          "kind": "array",
          "length": 32,
          "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
        },
        "visibility": "public"
      }
    ],
    "param_witnesses": {
      "hashed_message": [{ "start": 128, "end": 160 }],
      "pub_key_x": [{ "start": 0, "end": 32 }],
      "pub_key_y": [{ "start": 32, "end": 64 }],
      "signature": [{ "start": 64, "end": 128 }]
    },
    "return_type": { "abi_type": { "kind": "field" }, "visibility": "public" },
    "return_witnesses": [258]
  },
  "bytecode": "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",
  "debug_symbols": "zdvNaltXFIbhe9HYBK211/7zrZQOQptCICSlySz43pu2sVzIOdh9SktmCegTR8ePjfV66/Pl3YefXn96++H9x8v950uM6+X+h8+Xj7++fv/H/z9+ev3bp8t9tLreXd68//nLP+u6H+4uv7x99+ZyX/lw982Ds/evj809nh7aDh4akfX4vBnt6cH18OPdl4uJ/+5i/nz+/NfP3+LxBbRWz7zYXPn4vK32Ny+2/a8X09bT8x7c+fqeLqYfXkxFv43a+PvF/PW1fRWHdzRHzUcSo9bTrt92hbuOu4G7ibuFu227vOIucJe4Qy+JXhK9JHpJ9JLoJdFLQy8NvTT00tBLQy8NvTT00tBLQy8NvRR6KfRS6KXQS6GXQi+FXgq9FHop9NLRS0cvHb109NLRS0cvHb109NLRS0cvA70M9DLQy0AvA70M9DLQy0AvA70M9DLRy0QvE71M9DLRy0QvE71M9DLRy0QvC70s9LLQy0IvC70s9LLQy0IvC70s9LLRy0YvG71s9LLRy0YvG71s9LLRy0Yvcb3qMHSYOtRmd9Vod9Vqd9Vsd9Vud9Vwd1U5oXJC5YTK4drLuZd7LwdfLr6cfLX5hkbf0Oobmn1Du29o+A0tv6HpN7T9hsbf0Pobmn9D+29oAA4twKEJOLQBh0bg0AocmoFDO3BoCA4twaEpOIr/NqlytAaH5uDQHhwahEOLcGgSDm3CoVE4tAqHZuHQLhwahkPLcGgaDm3DoXE4tA6H5uHQPhwaiGPwiQiVo404NBKHVuLQTBzaiUNDcWgpDk3Foa04Jh+mUTmai0N7cWgwDi3Gock4tBmHRuPQahyajWPxOSyVo+U4NB2HtuPQeBxaj0PzcWg/Dg3IoQU5Nh/h4zN8eohPG3JqQ05tyKkNObUhpzbk1Iac2pBTG3IGH/9UOdqQUxtyakNObcipDTm1Iac25ORzw3xw2E8Oqxw+O8yHh/n0MB8f5vPDfIBYG3JqQ05tyNn40LnK0Yac2pBTG3JqQ05tyKkNObUhpzbk1IacxZ9XUDnakFMbcmpDTm3IqQ05tSGnNuTUhpzakFMbcmpDTm3IqQ05tSGnNuTUhpzakFMbcmpDTm3IOfhTUipHG3JqQ05tyKkNObUhpzbk1Iac2pBTG3JO/oCdytGGnNqQUxtyakNObch5FmZn3oazDocThyftcbZ4HM7WDoelw+NLnb3dhn0fDpcOtw3bSQl8wTB0OO2utpPY9YLhxuFJ7HrBMHSYeFdPYtcLhqXDrsOhw6nDEznjaTjjcLhxmPptlfptlSonVU6qnFQ5qXJS5eTSof5AbiqnqZymcprKaSqnqZymcprKaSqnqZxSOaVySuWUyimVUyqnVE6pnFI5pXK6yukq5yw9PffLfDtLT88Phw6nDpcOT94G7n27q9d5NDxLT88PT94G7rpd6u6Hw9Rh02HpsOtw6HDqcOlw4/AsPT0/VDlT5UyVM1XOVDlT5UyVM1XOVDlL5SyVs1TOUjlL5SyVs1TOUjlL5SyVs1XOVjmb5PRXh1+MGePratZTA8jbaMpoyWjL6LhtPbsKWiWtGq2KVp1WBCNIRhCNIBtJNpJsJNlIspFkI8lGko0kG0k2kmw0stHIRiMbjWw0stHIRiMbjWw0stHIRpGNIhtFNopsFNkoslFko8hGkY0iG51sdLLRyUYnG51sdLLRyUYnG51sdLIxyMYgG4NsDLIxyMYgG4NsDLIxyMYgG5NsTLIxycYkG5NsTLIx7Q0s2ZhkY5KNRTYW2VhkY5GNRTYW2VhkY1nd+Ic2Hh5+Bw==",
  "file_map": {
    "25": {
      "source": "mod hash;\nmod array;\nmod slice;\nmod merkle;\nmod schnorr;\nmod ecdsa_secp256k1;\nmod ecdsa_secp256r1;\nmod eddsa;\nmod grumpkin_scalar;\nmod grumpkin_scalar_mul;\nmod scalar_mul;\nmod sha256;\nmod sha512;\nmod field;\nmod ec;\nmod unsafe;\nmod collections;\nmod compat;\nmod option;\nmod string;\nmod test;\nmod cmp;\nmod ops;\nmod default;\nmod prelude;\nmod uint128;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(_with_newline: bool, _input: T) {}\n\nunconstrained pub fn print<T>(input: T) {\n    print_oracle(false, input);\n}\n\nunconstrained pub fn println<T>(input: T) {\n    print_oracle(true, input);\n}\n\n#[foreign(recursive_aggregation)]\npub fn verify_proof<N>(_verification_key: [Field], _proof: [Field], _public_inputs: [Field], _key_hash: Field) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(_x: T) {}\n// from_field and as_field are private since they are not valid for every type.\n// `as` should be the default for users to cast between primitive types, and in the future\n// traits can be used to work with generic types.\n#[builtin(from_field)]\nfn from_field<T>(_x: Field) -> T {}\n\n#[builtin(as_field)]\nfn as_field<T>(_x: T) -> Field {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T {\n    crate::from_field(crate::as_field(x) + crate::as_field(y))\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T {\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    crate::from_field(crate::as_field(x) + 340282366920938463463374607431768211456 - crate::as_field(y))\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T {\n    crate::from_field(crate::as_field(x) * crate::as_field(y))\n}\n",
      "path": "std/lib.nr"
    },
    "42": {
      "source": "// use dep::std;\n\n// #[oracle(getSqrt)]\n// unconstrained fn sqrt(numbers: [Field; 2]) -> [Field; 2] {}\n\n// unconstrained fn get_sqrt(numbers: [Field; 2]) -> [Field; 2] {\n//     sqrt(numbers)\n// }\n\n// fn main(input: [Field; 2]) {\n//     let sqrt = get_sqrt(input);\n//     assert(sqrt[0].pow_32(2) as u64 == input[0] as u64);\n//     assert(sqrt[1].pow_32(2) as u64 == input[1] as u64);\n// }\n\n// #[test]\n// fn test_main() {\n//     let input = [4, 16];\n//     main(input)\n// }\n\n// #[test(should_fail)]\n// fn test_fail() {\n//     let input = [4, 15];\n//     main(input)\n// }\n\n// // fn main(x: Field, y: Field, sqrt_x: Field, sqrt_y: Field) -> pub Field {\n// //     let sqrt= get_sqrt([x, y]);\n// //     assert(sqrt[0].pow_32(2) as u64 == x as u64);\n// //     assert(sqrt[1].pow_32(2) as u64 == y as u64);\n// //     assert(sqrt[0] == sqrt_x, \"sqrt_x is not the square root of x\");\n// //     assert(sqrt[1] == sqrt_y, \"sqrt_y is not the square root of y\");\n// //     sqrt_x * sqrt_y\n// // }\n\n// // #[test]\n// // fn test_main() {\n// //     main(9, 16, 3, 4);\n// // }\n\n// // #[test(should_fail)]\n// // fn test_main_fail() {\n// //     main(9, 16, 2, 1);\n// // }\n\nuse dep::std;\nuse dep::ecrecover;\n\nfn main(\n    pub_key_x: [u8; 32],\n    pub_key_y: [u8; 32],\n    signature: [u8; 64],\n    hashed_message: pub [u8; 32]\n) -> pub Field {\n    let address = ecrecover::ecrecover(pub_key_x, pub_key_y, signature, hashed_message);\n    std::println(address);\n\n    address // address is represented as `Field`, but is constrained to be within 160 bits\n}\n",
      "path": "/Users/gabrielantonyxaviour/Developer/projects/ongoing/priv.cast/circuits/src/main.nr"
    },
    "43": {
      "source": "use dep::std;\n \nmod secp256k1;\n\nfn ecrecover(\n    pub_key_x: [u8; 32],\n    pub_key_y: [u8; 32],\n    signature: [u8; 64], // clip v value\n    hashed_message: [u8; 32]\n) -> Field {\n    let key = secp256k1::PubKey::from_xy(pub_key_x, pub_key_y);\n\n    assert(key.verify_sig(signature, hashed_message));\n    let addr = key.to_eth_address();\n\n    addr\n}\n\n#[test]\nfn test_ecrecover() {\n    let pub_key_x = [131, 24, 83, 91, 84, 16, 93, 74, 122, 174, 96, 192, 143, 196, 95, 150, 135, 24, 27, 79, 223, 198, 37, 189, 26, 117, 63, 167, 57, 127, 237, 117];\n    let pub_key_y = [53, 71, 241, 28, 168, 105, 102, 70, 242, 243, 172, 176, 142, 49, 1, 106, 250, 194, 62, 99, 12, 93, 17, 245, 159, 97, 254, 245, 123, 13, 42, 165];\n    let signature = [57, 17, 112, 239, 241, 30, 64, 157, 170, 50, 85, 145, 156, 69, 226, 85, 147, 164, 10, 82, 71, 93, 42, 132, 200, 220, 161, 255, 95, 241, 211, 141, 81, 7, 150, 25, 25, 27, 162, 213, 80, 61, 12, 170, 50, 4, 154, 203, 252, 229, 119, 29, 202, 153, 50, 25, 126, 145, 245, 23, 136, 75, 29, 177];\n    let hashed_message = [13, 82, 120, 60, 76, 186, 215, 235, 175, 126, 185, 67, 252, 100, 143, 82, 130, 165, 32, 112, 68, 47, 193, 141, 141, 209, 109, 219, 47, 203, 175, 102];\n\n    let addr = ecrecover(pub_key_x, pub_key_y, signature, hashed_message);\n    assert(addr == 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266);\n}\n",
      "path": "/Users/gabrielantonyxaviour/nargo/github.com/colinnielsen/ecrecover-noirv0.19.0/src/lib.nr"
    },
    "44": {
      "source": "use dep::std;\n\nuse dep::array_helpers;\n\nstruct PubKey {\n    pub_x: [u8; 32],\n    pub_y: [u8; 32],\n}\n\nunconstrained\nfn split_uncompressed_pub_key(\n    pub_key: [u8; 65]\n) -> ([u8; 32], [u8; 32]) {\n    let mut pub_key_x: [u8; 32] = [0; 32];\n    let mut pub_key_y: [u8; 32] = [0; 32];\n\n    for i in 0..32 {\n        pub_key_x[i] = pub_key[i + 1];\n        pub_key_y[i] = pub_key[i + 32 + 1];\n    };\n\n    (pub_key_x, pub_key_y)\n}\n\nimpl PubKey {\n    fn from_xy(pub_x: [u8; 32], pub_y: [u8; 32]) -> PubKey {\n        PubKey {\n            pub_x,\n            pub_y,\n        }\n    }\n\n    fn from_unified(pub_key: [u8; 64]) -> PubKey {\n        let (key_x, key_y) = array_helpers::split_u8_64_unconstrained(pub_key);\n\n        PubKey {\n            pub_x: key_x,\n            pub_y: key_y,\n        }\n    }\n\n    fn from_uncompressed(pub_key: [u8; 65]) -> PubKey {\n        assert(pub_key[0] == 0x04);\n        let (key_x, key_y) = split_uncompressed_pub_key(pub_key);\n\n        PubKey {\n            pub_x: key_x,\n            pub_y: key_y,\n        }\n    }\n\n    fn verify_sig(self, signature: [u8; 64], hashed_message: [u8; 32]) -> bool {\n        std::ecdsa_secp256k1::verify_signature(self.pub_x, self.pub_y, signature, hashed_message)\n    }\n\n    fn to_eth_address(self) -> Field {\n        let pub_key = array_helpers::u8_32_to_u8_64_unconstrained(self.pub_x, self.pub_y);\n        let hashed_pub_key = std::hash::keccak256(pub_key, 64);\n\n        let mut addr: Field = 0;\n        for i in 0..20 {\n            // shift left by 8 and add the new value\n            addr = (addr * 256) + hashed_pub_key[i + 12] as Field;\n        }\n\n        addr\n    }\n\n    fn ecrecover(\n        self,\n        signature: [u8; 64],\n        hashed_message: [u8; 32]\n    ) -> Field {\n        assert(self.verify_sig(signature, hashed_message));\n\n        self.to_eth_address()\n    }\n}\n\n\n#[test]\nfn test_ecrecover_via_key() {\n    let pub_key_x = [131, 24, 83, 91, 84, 16, 93, 74, 122, 174, 96, 192, 143, 196, 95, 150, 135, 24, 27, 79, 223, 198, 37, 189, 26, 117, 63, 167, 57, 127, 237, 117];\n    let pub_key_y = [53, 71, 241, 28, 168, 105, 102, 70, 242, 243, 172, 176, 142, 49, 1, 106, 250, 194, 62, 99, 12, 93, 17, 245, 159, 97, 254, 245, 123, 13, 42, 165];\n    let signature = [57, 17, 112, 239, 241, 30, 64, 157, 170, 50, 85, 145, 156, 69, 226, 85, 147, 164, 10, 82, 71, 93, 42, 132, 200, 220, 161, 255, 95, 241, 211, 141, 81, 7, 150, 25, 25, 27, 162, 213, 80, 61, 12, 170, 50, 4, 154, 203, 252, 229, 119, 29, 202, 153, 50, 25, 126, 145, 245, 23, 136, 75, 29, 177];\n    let hashed_message = [13, 82, 120, 60, 76, 186, 215, 235, 175, 126, 185, 67, 252, 100, 143, 82, 130, 165, 32, 112, 68, 47, 193, 141, 141, 209, 109, 219, 47, 203, 175, 102];\n\n    let key = PubKey::from_xy(pub_key_x, pub_key_y);\n    assert(key.ecrecover(signature, hashed_message) == 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266);\n}\n",
      "path": "/Users/gabrielantonyxaviour/nargo/github.com/colinnielsen/ecrecover-noirv0.19.0/src/secp256k1.nr"
    },
    "45": {
      "source": "use dep::std;\n\nfn u8_32s_to_u64_16(\n    arr_a: [u8; 32],\n    arr_b: [u8; 32],\n) -> [u64; 16] {\n    let mut combined_u64: [u64; 16] = [0; 16];\n    \n    for i in 0..4 {\n        let mut value: u64 = 0;\n        for j in 0..8 {\n            value |= (arr_a[i*8+j] as u64) << ((56 - j*8) as u64);\n        }\n         combined_u64[i] = value;\n    }\n    for i in 4..8 {\n        let mut value: u64 = 0;\n        for j in 0..8 {\n            value |= (arr_b[(i-4)*8+j] as u64) << ((56 - j*8) as u64);\n        }\n         combined_u64[i] = value;\n    }\n\n    combined_u64\n}\n\nunconstrained\nfn u8_32s_to_u64_16_unconstrained(\n    arr_a: [u8; 32],\n    arr_b: [u8; 32],\n) -> [u64; 16] {\n    let mut combined_u64: [u64; 16] = [0; 16];\n    \n    for i in 0..4 {\n        let mut value: u64 = 0;\n        for j in 0..8 {\n            value |= (arr_a[i*8+j] as u64) << ((56 - j*8) as u64);\n        }\n         combined_u64[i] = value;\n    }\n    for i in 4..8 {\n        let mut value: u64 = 0;\n        for j in 0..8 {\n            value |= (arr_b[(i-4)*8+j] as u64) << ((56 - j*8) as u64);\n        }\n         combined_u64[i] = value;\n    }\n\n    combined_u64\n}\n\n#[test]\nfn test_u8_32s_to_u64_16() {\n    let arr_a: [u8; 32] = [\n        131,24,83,91,84,16,93,74,122,174,96,192,143,196,95,150,135,24,27,79,223,198,37,189,26,117,63,167,57,127,237,117\n    ];\n    let arr_b: [u8; 32] = [\n        53,71,241,28,168,105,102,70,242,243,172,176,142,49,1,106,250,194,62,99,12,93,17,245,159,97,254,245,123,13,42,165\n    ];\n    let out = u8_32s_to_u64_16(arr_a, arr_b);\n\n    assert(out[0] == 9446391870127103306);\n    assert(out[1] == 8840109498736861078);\n    assert(out[2] == 9734560624431998397);\n    assert(out[3] == 1906500004718046581);\n    assert(out[4] == 3839302312743495238);\n    assert(out[5] == 17506526050819047786);\n    assert(out[6] == 18069073250093961717);\n    assert(out[7] == 11484740855056378533);\n    assert(out[8] == 0);\n    assert(out[9] == 0);\n    assert(out[10] == 0);\n    assert(out[11] == 0);\n    assert(out[12] == 0);\n    assert(out[13] == 0);\n    assert(out[14] == 0);\n    assert(out[15] == 0);\n    // the above output is the hex \"0x8318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5\"\n}\n\nfn u8_32_to_u8_64(\n    arr_a: [u8; 32],\n    arr_b: [u8; 32],\n) -> [u8; 64] {\n    let mut combined: [u8; 64] = [0; 64];\n\n    for i in 0..32 {\n        combined[i] = arr_a[i];\n    }\n    for i in 0..32 {\n        combined[i + 32] = arr_b[i];\n    }\n\n    combined\n}\n\nunconstrained\nfn u8_32_to_u8_64_unconstrained(\n    arr_a: [u8; 32],\n    arr_b: [u8; 32],\n) -> [u8; 64] {\n    let mut combined: [u8; 64] = [0; 64];\n\n    for i in 0..32 {\n        combined[i] = arr_a[i];\n    }\n    for i in 0..32 {\n        combined[i + 32] = arr_b[i];\n    }\n\n    combined\n}\n\n\nfn u64_4_to_u8_32(\n    array: [u64; 4]\n) -> [u8; 32] {\n    let mut output: [u8; 32] = [0; 32];\n    let mut output_index = 0;\n\n    for num_idx in 0..4 {\n        for bit_pos in 0..8 {\n            let shift_amount: u64 = 56 - (bit_pos * 8) as u64;\n            output[output_index] = ((array[num_idx] >> shift_amount) & 255) as u8;\n            output_index += 1;\n        }\n    }\n\n    output\n}\n\nunconstrained\nfn u64_4_to_u8_32_unconstrained(\n    array: [u64; 4]\n) -> [u8; 32] {\n    let mut output: [u8; 32] = [0; 32];\n    let mut output_index = 0;\n\n    for num_idx in 0..4 {\n        for bit_pos in 0..8 {\n            let shift_amount: u64 = 56 - (bit_pos * 8) as u64;\n            output[output_index] = ((array[num_idx] >> shift_amount) & 255) as u8;\n            output_index += 1;\n        }\n    }\n\n    output\n}\n\n#[test]\nfn test_u64_4_to_u8_32() {\n    let hash: [u64; 4] = [\n        999647796417551690,\n        8840109498736861078,\n        9734560624431998397,\n        1906500004718046581\n    ];\n \n    let arr_out = u64_4_to_u8_32(hash);\n\n    assert(arr_out[0] == 13);\n    assert(arr_out[1] == 223);\n    assert(arr_out[2] == 118);\n    assert(arr_out[3] == 95);\n    assert(arr_out[4] == 221);\n    assert(arr_out[5] == 248);\n    assert(arr_out[6] == 93);\n    assert(arr_out[7] == 74);\n    assert(arr_out[8] == 122);\n    assert(arr_out[9] == 174);\n    assert(arr_out[10] == 96);\n    assert(arr_out[11] == 192);\n    assert(arr_out[12] == 143);\n    assert(arr_out[13] == 196);\n    assert(arr_out[14] == 95);\n    assert(arr_out[15] == 150);\n    assert(arr_out[16] == 135);\n    assert(arr_out[17] == 24);\n    assert(arr_out[18] == 27);\n    assert(arr_out[19] == 79);\n    assert(arr_out[20] == 223);\n    assert(arr_out[21] == 198);\n    assert(arr_out[22] == 37);\n    assert(arr_out[23] == 189);\n    assert(arr_out[24] == 26);\n    assert(arr_out[25] == 117);\n    assert(arr_out[26] == 63);\n    assert(arr_out[27] == 167);\n    assert(arr_out[28] == 57);\n    assert(arr_out[29] == 127);\n    assert(arr_out[30] == 237);\n    assert(arr_out[31] == 117);\n}\n\n/// @dev this method is used to convert a u8 array to a u160 (which is not supported by Noir, so it's represented as a Field)\n/// @dev will throw on Field overflow\nfn u8_to_u160(\n    array: [u8]\n) -> Field {\n    let mut addr: Field = 0;\n\n    for i in 0..20 {\n        // only take the last 20 bytes of the hash\n        addr = (addr * 256) + (array[i] as Field);\n    }\n\n    addr\n}\n\nunconstrained\nfn u8_to_u160_unconstrained(\n    array: [u8]\n) -> Field {\n    let mut addr: Field = 0;\n\n    for i in 0..20 {\n        // only take the last 20 bytes of the hash\n        addr = (addr * 256) + (array[i] as Field);\n    }\n\n    addr\n}\n\nfn u8_to_eth_address(\n    array: [u8]\n) -> Field {\n    u8_to_u160(array)\n}\n\nunconstrained\nfn u8_to_eth_address_unconstrained(\n    array: [u8]\n) -> Field {\n    u8_to_u160(array)\n}\n\n#[test]\nfn test_u8_32_to_u160() {\n    // keccak hash of hardhat 0 address pub key (0xc1ffd3cfee2d9e5cd67643f8f39fd6e51aad88f6f4ce6ab8827279cfffb92266) as u8 array\n    let hashed_pub_key = [\n        193,255,211,207,238,45,158,92,214,118,67,248,243,159,214,229,26,173,136,246,244,206,106,184,130,114,121,207,255,185,34,102\n    ];\n\n    let mut right_20_bytes: [u8] = [0; 20];\n    for i in 0..20 {\n        right_20_bytes[i] = hashed_pub_key[i + 12];\n    }\n\n    let addr = u8_to_u160(right_20_bytes);\n    let addr_aliased = u8_to_eth_address(right_20_bytes);\n\n    assert(addr == addr_aliased);\n    assert(addr == 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266); // hardhat address 0\n}\n\nfn split_u8_64(\n    arr: [u8; 64]\n) -> ([u8; 32], [u8; 32]) {\n    let mut arr_a: [u8; 32] = [0; 32];\n    let mut arr_b: [u8; 32] = [0; 32];\n\n    for i in 0..32 {\n        arr_a[i] = arr[i];\n        arr_b[i] = arr[i + 32];\n    };\n\n    (arr_a, arr_b)\n}\n\nunconstrained\nfn split_u8_64_unconstrained(\n    arr: [u8; 64]\n) -> ([u8; 32], [u8; 32]) {\n    let mut arr_a: [u8; 32] = [0; 32];\n    let mut arr_b: [u8; 32] = [0; 32];\n\n    for i in 0..32 {\n        arr_a[i] = arr[i];\n        arr_b[i] = arr[i + 32];\n    };\n\n    (arr_a, arr_b)\n}\n\n#[test]\nfn test_split_u8_64() {\n    let u8_64 = [\n        193,255,211,207,238,45,158,92,214,118,67,248,243,159,214,229,26,173,136,246,244,206,106,184,130,114,121,207,255,185,34,102,\n        193,255,211,207,238,45,158,92,214,118,67,248,243,159,214,229,26,173,136,246,244,206,106,184,130,114,121,207,255,185,34,102\n    ];\n\n    let (arr_a, arr_b) = split_u8_64(u8_64);\n\n    for i in 0..32 {\n        assert(arr_a[i] == u8_64[i]);\n        assert(arr_b[i] == u8_64[i + 32]);\n    }\n}\n",
      "path": "/Users/gabrielantonyxaviour/nargo/github.com/colinnielsen/noir-array-helpersv0.19.0/src/lib.nr"
    }
  }
}
