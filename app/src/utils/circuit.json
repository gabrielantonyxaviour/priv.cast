{
  "noir_version": "0.23.0+5be9f9d7e2f39ca228df10e5a530474af0331704",
  "hash": 5695580416348832080,
  "abi": {
    "parameters": [
      {
        "name": "input",
        "type": { "kind": "array", "length": 2, "type": { "kind": "field" } },
        "visibility": "private"
      }
    ],
    "param_witnesses": { "input": [{ "start": 0, "end": 2 }] },
    "return_type": null,
    "return_witnesses": []
  },
  "bytecode": "H4sIAAAAAAAA/+1a227aQBAdjO2YQNKQG0laVVVVta+72GD7LXxDvwArdp9b5fv6ay2r7ErDxiAlnEEgGAmtbxxmzszOHhZ+EJGmF+suXh17bMaAls3de7Sj2sw0EEtJ+dgB+tjGbWB5v7HnPXrNe2yfQcYVM3wQ5jjG8696HleOI8eHGyN7ndjI33NueQzBPHaYDw7XnYcsfzGY6x7Dd9bxzh/ZcczGCMxBssA4sVi/6uefv/8881IPvVSsmgbGegwqZNcSexyxa+49J+yaoz5h93xaYHF3aXmuontP4OGDcBW12DuxtX+B+xuypEWMo4Dd/9fCX4cdB/aZYM0znRU4q/qAWEG44Exgf1mwEfsMqSLxcVM1zbI6H9c61XM1LqtiorJJNS10oSfF5GlcpGldZEVeVmWuSp2ltW4mZdpY4E8kU3DdzfxUnp86BMYcAfMixV8Arh8kf/EarCKvqybP0rnKmmqBM23qdD4udVOkC/g009W8Vk9ZlU+zadHkiotRbuj5E+OwFPfXrDz+ysfrX0AsafI+x+dPtPlJJedEADchXNFLxZ3gc9TqK6JpJgK4n2k7C5B6o/l+Imuph4tZI/lzQsb4N7Mc+t9SJeYBEGtrqvfUjn06MNVrAueqt0/LX0GNobcxONamSvKUcBO5TzKFi1Z/yJgHtH/qb0DYJunsjI7qD5KcMwHcc9pt9TewyQLnSET99b3CQuF+IZkGilZ/yFr6gItZI/lzC7rxb0bLhl6QInBtojiQ3uvt0uvfERB+U4u9E3ut6r2w45AOTPWawLnqHZLcXq8rEnSz/UrbababKvQLYMxDYF6k+EM3VyR/l7R/av+SsIuisys6qn1Icq4EcK9pt9W+ifsanyMRtT+0vqJxv9F2FiD1RvP9RNbSDS5mjeTPCRnj3zb3epH/tGpxV0T13tpxRAemek3gXPWOSH6vlxfIpkrylnATeUQyhYtWf8iY72j/1N8dYZuks3s6qj9Icu4FcB9ot9WfifsBnyMR9TeyvqJxv5NMA0WrP2QtfcTFrJH8uQXd+DejZUMvSENwbaI4aNvnbbP/EnVljDwxAAA=",
  "debug_symbols": "ndbBaoQwEIDhd8lZSmYmiYmvUnqQdgsLi1uqN/Hdu6WVBQ3I7y05fKefyWR2t/t7P13vw+i62XnXvc5u/OqH39s49d+T61StcZfh43GyvDTu83q7uM7K8tY4qYIoK2jjBigFRkGgIFKQKGgpyBQUCsRjgVsLji312m1ZRQlbEbCIWCQsWiwyFoUK9VgIFooFbq5HI74X1ebm878w061IWLRYZCwKFeaxECwUC8MiYIGbG25u9eaWVhFlKzIWhYrgsRAsFAvDImARsUhY4ObhaM53wr9Uo0tanzjJz5+YpD9SX+kHRupGV7Nb0Q+jJ4ydMOGEicwsyw8=",
  "file_map": {
    "16": {
      "source": "mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n    \n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(_self: Self, _bit_size: u32) -> [u1] {}\n    \n    #[builtin(to_be_bits)]\n    fn __to_be_bits(_self: Self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(_self: Self, _bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(_self: Self, _radix: u32, _result_len: u32) -> [u8] {}\n    \n    #[builtin(to_be_radix)]\n    fn __to_be_radix(_self: Self, _radix: u32, _result_len: u32) -> [u8] {}\n\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x âˆˆ {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n}\n\n#[builtin(modulus_num_bits)]\npub fn modulus_num_bits() -> Field {}\n\n#[builtin(modulus_be_bits)]\npub fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub fn modulus_le_bytes() -> [u8] {}\n// Convert a 32 byte array to a field element\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n",
      "path": "std/field.nr"
    },
    "39": {
      "source": "use dep::std;\n\n#[oracle(getSqrt)]\nunconstrained fn sqrt(numbers: [Field; 2]) -> [Field; 2] {}\n\nunconstrained fn get_sqrt(numbers: [Field; 2]) -> [Field; 2] {\n    sqrt(numbers)\n}\n\nfn main(input: [Field; 2]) {\n    let sqrt = get_sqrt(input);\n    assert(sqrt[0].pow_32(2) as u64 == input[0] as u64);\n    assert(sqrt[1].pow_32(2) as u64 == input[1] as u64);\n}\n\n#[test]\nfn test_main() {\n    let input = [4, 16];\n    main(input)\n}\n\n#[test(should_fail)]\nfn test_fail() {\n    let input = [4, 15];\n    main(input)\n}\n\n// fn main(x: Field, y: Field, sqrt_x: Field, sqrt_y: Field) -> pub Field {\n//     let sqrt= get_sqrt([x, y]);\n//     assert(sqrt[0].pow_32(2) as u64 == x as u64);\n//     assert(sqrt[1].pow_32(2) as u64 == y as u64);\n//     assert(sqrt[0] == sqrt_x, \"sqrt_x is not the square root of x\");\n//     assert(sqrt[1] == sqrt_y, \"sqrt_y is not the square root of y\");\n//     sqrt_x * sqrt_y\n// }\n\n// #[test]\n// fn test_main() {\n//     main(9, 16, 3, 4);\n// }\n\n// #[test(should_fail)]\n// fn test_main_fail() {\n//     main(9, 16, 2, 1);\n// }",
      "path": "/Users/gabrielantonyxaviour/Developer/projects/Ongoing projects/priv.cast/circuits/src/main.nr"
    }
  }
}
