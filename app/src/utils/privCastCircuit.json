{
  "noir_version": "0.23.0+5be9f9d7e2f39ca228df10e5a530474af0331704",
  "hash": 14603027173288191367,
  "abi": {
    "parameters": [
      {
        "name": "signer_pub_x_key",
        "type": {
          "kind": "array",
          "length": 32,
          "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
        },
        "visibility": "private"
      },
      {
        "name": "signer_pub_y_key",
        "type": {
          "kind": "array",
          "length": 32,
          "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
        },
        "visibility": "private"
      },
      {
        "name": "signature",
        "type": {
          "kind": "array",
          "length": 64,
          "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
        },
        "visibility": "private"
      },
      {
        "name": "hashed_message",
        "type": {
          "kind": "array",
          "length": 32,
          "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
        },
        "visibility": "private"
      },
      {
        "name": "farcaster_id",
        "type": { "kind": "field" },
        "visibility": "private"
      },
      {
        "name": "vote_priv",
        "type": { "kind": "field" },
        "visibility": "private"
      },
      {
        "name": "poll_id",
        "type": {
          "kind": "array",
          "length": 32,
          "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
        },
        "visibility": "public"
      },
      { "name": "vote", "type": { "kind": "field" }, "visibility": "public" },
      {
        "name": "nullifier",
        "type": {
          "kind": "array",
          "length": 32,
          "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
        },
        "visibility": "public"
      }
    ],
    "param_witnesses": {
      "farcaster_id": [{ "start": 160, "end": 161 }],
      "hashed_message": [{ "start": 128, "end": 160 }],
      "nullifier": [{ "start": 195, "end": 227 }],
      "poll_id": [{ "start": 162, "end": 194 }],
      "signature": [{ "start": 64, "end": 128 }],
      "signer_pub_x_key": [{ "start": 0, "end": 32 }],
      "signer_pub_y_key": [{ "start": 32, "end": 64 }],
      "vote": [{ "start": 194, "end": 195 }],
      "vote_priv": [{ "start": 161, "end": 162 }]
    },
    "return_type": {
      "abi_type": {
        "kind": "array",
        "length": 32,
        "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
      },
      "visibility": "public"
    },
    "return_witnesses": [
      195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209,
      210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224,
      225, 226
    ]
  },
  "bytecode": "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",
  "debug_symbols": "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MLQHQ3swtAdDezC0B0N7MLQHQ3swtQdTezC1B1N7MLUHU3swtQdTezC1B1N7MLUHU3swtQdTezC1B1N7MLUHU3swtQdTezC1B1N7MLUHU3swtQdTezC1B1N7MLUHU3swtQdTezC1B1N7MLUHU3swtQdTezC1B1N7MLUHU3swtQdTezC1B1N7MLUHU3swtQdTezC1B1N7MLUHU3swtQdTezC1B1N7MLUHU3swtQdTezC1B1N7MLUHU3swtQdTezC1B1N7MLUHU3swtQdTezC1B1N7MLUHU3swtQdTezC1B1N7MLUHU3swtQdTezC1B1N7MLUHU3swtQdTezC1B1N7MLUHU3swtQdTezC1B1N7MLUHU3swtQdTezC1B1N7MLUHU3swtQdTezC1B1N7MLUHU3swtQdTezC1B1N7MLUHU3swtQdTezC1B1N7MLUHU3swtQdTezC1B1N7MLUHU3swtQdTezC1B1N7MLUHU3swtQdTezC1B1N7MLUHU3swtQdTezC1B1N7MLUHU3swtQdTezC1B1N7MLUHU3swtQdTezC1B1N7MLUHU3swtQdTezC1B1N7MLUHU3swtQdTezC1B1N7MLUHU3swtQdTezC1B1N7MLUHU3swtQdTezC1B1N7MLUHU3swtQdTezC1B1N7MLUHU3swtQdTezC1B1N7MLUHU3swtQdTezC1B1N7MLUHU3swtQdTezC1B1N7MLUHU3swtQdTezC1B1N7MLUHU3swtQdTezC1B1N7MLUHU3swtQdTezC1B1N7MLUHU3swtQdTezC1B1N7MLUHU3swtQdTezC1B1N7MLUHU3swtQdTezC1B1N7MLUHU3swtQdTezC1B1N7MLUHU3swtQdTezC1B1N7MLUHU3swtQdTezC1B1N7MLUHU3swtQdTezC1B1N7MLUHU3swtQdTezC1B1N7MLUHM3twuc3v7r6m43ieOkefLZ3L++/fv/8P",
  "file_map": {
    "43": {
      "source": "use dep::std;\nuse dep::ecrecover;\n\n#[oracle(getFid)]\nunconstrained fn farcaster_id(address: Field) -> Field {}\n\nunconstrained fn get_farcaster_id(address: Field) -> Field {\n    farcaster_id(address)\n}\n\nfn main(\n    signer_pub_x_key: [u8; 32],\n    signer_pub_y_key: [u8; 32],\n    signature: [u8; 64],\n    hashed_message: [u8; 32],\n    farcaster_id: Field,\n    vote_priv: Field,\n    poll_id: pub [u8; 32],\n    vote: pub Field,\n    nullifier: pub [u8; 32]\n) -> pub [u8; 32] {\n    // TODO: eth-signed hash\n    // // let hash_data: [u8; 32] = get_hash_data(poll_id, farcaster_id.to_be_bytes(32));\n    let computedAddress: Field = ecrecover::secp256k1::PubKey::from_xy(signer_pub_x_key, signer_pub_y_key).to_eth_address(); // Compute address from public key\n    let recoveredAddress = ecrecover::ecrecover(signer_pub_x_key, signer_pub_y_key, signature, hashed_message); // Ecrecover signature and verify\n    assert(recoveredAddress == computedAddress); // Check recovered address is computed address\n\n    let gen_nullifier = std::hash::keccak256(signature, 64); // generate nullifier\n    assert(gen_nullifier == nullifier); // Check if nullifier hash is valid\n\n    let fid: Field = get_farcaster_id(recoveredAddress); // Call oracle to get farcaster id\n    assert(fid != 0); // Check if farcaster id is non zero\n    assert(fid == farcaster_id); // Check if farcaster id is valid\n\n    assert(vote as u8 == vote_priv as u8); // Check if the vote is right\n\n    // Return nullifier\n    nullifier\n}\n\nfn get_hash_data(poll_id: [u8; 32], farcaster_id: [u8]) -> [u8; 32] {\n    let mut combined_key: [u8; 64] = [0; 64];\n    for i in 0..32 {\n        combined_key[i]=poll_id[i];\n    }\n    for i in 0..32 {\n        combined_key[i+32]=farcaster_id[i];\n    }\n\n    let hashed_message = std::hash::keccak256(combined_key, 64);\n    hashed_message\n}\n\nfn u8_to_u160(array: [u8]) -> Field {\n    let mut addr: Field = 0;\n    for i in 0..20 {\n        // only take the last 20 bytes of the hash\n        addr = (addr * 256) + (array[i] as Field);\n    }\n    addr\n}\n",
      "path": "/Users/gabrielantonyxaviour/Developer/projects/ongoing/priv.cast/circuits/src/main.nr"
    },
    "44": {
      "source": "use dep::std;\n \nmod secp256k1;\n\nfn ecrecover(\n    pub_key_x: [u8; 32],\n    pub_key_y: [u8; 32],\n    signature: [u8; 64], // clip v value\n    hashed_message: [u8; 32]\n) -> Field {\n    let key = secp256k1::PubKey::from_xy(pub_key_x, pub_key_y);\n\n    assert(key.verify_sig(signature, hashed_message));\n    let addr = key.to_eth_address();\n\n    addr\n}\n\n#[test]\nfn test_ecrecover() {\n    let pub_key_x = [131, 24, 83, 91, 84, 16, 93, 74, 122, 174, 96, 192, 143, 196, 95, 150, 135, 24, 27, 79, 223, 198, 37, 189, 26, 117, 63, 167, 57, 127, 237, 117];\n    let pub_key_y = [53, 71, 241, 28, 168, 105, 102, 70, 242, 243, 172, 176, 142, 49, 1, 106, 250, 194, 62, 99, 12, 93, 17, 245, 159, 97, 254, 245, 123, 13, 42, 165];\n    let signature = [57, 17, 112, 239, 241, 30, 64, 157, 170, 50, 85, 145, 156, 69, 226, 85, 147, 164, 10, 82, 71, 93, 42, 132, 200, 220, 161, 255, 95, 241, 211, 141, 81, 7, 150, 25, 25, 27, 162, 213, 80, 61, 12, 170, 50, 4, 154, 203, 252, 229, 119, 29, 202, 153, 50, 25, 126, 145, 245, 23, 136, 75, 29, 177];\n    let hashed_message = [13, 82, 120, 60, 76, 186, 215, 235, 175, 126, 185, 67, 252, 100, 143, 82, 130, 165, 32, 112, 68, 47, 193, 141, 141, 209, 109, 219, 47, 203, 175, 102];\n\n    let addr = ecrecover(pub_key_x, pub_key_y, signature, hashed_message);\n    assert(addr == 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266);\n}\n",
      "path": "/Users/gabrielantonyxaviour/nargo/github.com/colinnielsen/ecrecover-noirv0.19.0/src/lib.nr"
    },
    "45": {
      "source": "use dep::std;\n\nuse dep::array_helpers;\n\nstruct PubKey {\n    pub_x: [u8; 32],\n    pub_y: [u8; 32],\n}\n\nunconstrained\nfn split_uncompressed_pub_key(\n    pub_key: [u8; 65]\n) -> ([u8; 32], [u8; 32]) {\n    let mut pub_key_x: [u8; 32] = [0; 32];\n    let mut pub_key_y: [u8; 32] = [0; 32];\n\n    for i in 0..32 {\n        pub_key_x[i] = pub_key[i + 1];\n        pub_key_y[i] = pub_key[i + 32 + 1];\n    };\n\n    (pub_key_x, pub_key_y)\n}\n\nimpl PubKey {\n    fn from_xy(pub_x: [u8; 32], pub_y: [u8; 32]) -> PubKey {\n        PubKey {\n            pub_x,\n            pub_y,\n        }\n    }\n\n    fn from_unified(pub_key: [u8; 64]) -> PubKey {\n        let (key_x, key_y) = array_helpers::split_u8_64_unconstrained(pub_key);\n\n        PubKey {\n            pub_x: key_x,\n            pub_y: key_y,\n        }\n    }\n\n    fn from_uncompressed(pub_key: [u8; 65]) -> PubKey {\n        assert(pub_key[0] == 0x04);\n        let (key_x, key_y) = split_uncompressed_pub_key(pub_key);\n\n        PubKey {\n            pub_x: key_x,\n            pub_y: key_y,\n        }\n    }\n\n    fn verify_sig(self, signature: [u8; 64], hashed_message: [u8; 32]) -> bool {\n        std::ecdsa_secp256k1::verify_signature(self.pub_x, self.pub_y, signature, hashed_message)\n    }\n\n    fn to_eth_address(self) -> Field {\n        let pub_key = array_helpers::u8_32_to_u8_64_unconstrained(self.pub_x, self.pub_y);\n        let hashed_pub_key = std::hash::keccak256(pub_key, 64);\n\n        let mut addr: Field = 0;\n        for i in 0..20 {\n            // shift left by 8 and add the new value\n            addr = (addr * 256) + hashed_pub_key[i + 12] as Field;\n        }\n\n        addr\n    }\n\n    fn ecrecover(\n        self,\n        signature: [u8; 64],\n        hashed_message: [u8; 32]\n    ) -> Field {\n        assert(self.verify_sig(signature, hashed_message));\n\n        self.to_eth_address()\n    }\n}\n\n\n#[test]\nfn test_ecrecover_via_key() {\n    let pub_key_x = [131, 24, 83, 91, 84, 16, 93, 74, 122, 174, 96, 192, 143, 196, 95, 150, 135, 24, 27, 79, 223, 198, 37, 189, 26, 117, 63, 167, 57, 127, 237, 117];\n    let pub_key_y = [53, 71, 241, 28, 168, 105, 102, 70, 242, 243, 172, 176, 142, 49, 1, 106, 250, 194, 62, 99, 12, 93, 17, 245, 159, 97, 254, 245, 123, 13, 42, 165];\n    let signature = [57, 17, 112, 239, 241, 30, 64, 157, 170, 50, 85, 145, 156, 69, 226, 85, 147, 164, 10, 82, 71, 93, 42, 132, 200, 220, 161, 255, 95, 241, 211, 141, 81, 7, 150, 25, 25, 27, 162, 213, 80, 61, 12, 170, 50, 4, 154, 203, 252, 229, 119, 29, 202, 153, 50, 25, 126, 145, 245, 23, 136, 75, 29, 177];\n    let hashed_message = [13, 82, 120, 60, 76, 186, 215, 235, 175, 126, 185, 67, 252, 100, 143, 82, 130, 165, 32, 112, 68, 47, 193, 141, 141, 209, 109, 219, 47, 203, 175, 102];\n\n    let key = PubKey::from_xy(pub_key_x, pub_key_y);\n    assert(key.ecrecover(signature, hashed_message) == 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266);\n}\n",
      "path": "/Users/gabrielantonyxaviour/nargo/github.com/colinnielsen/ecrecover-noirv0.19.0/src/secp256k1.nr"
    },
    "46": {
      "source": "use dep::std;\n\nfn u8_32s_to_u64_16(\n    arr_a: [u8; 32],\n    arr_b: [u8; 32],\n) -> [u64; 16] {\n    let mut combined_u64: [u64; 16] = [0; 16];\n    \n    for i in 0..4 {\n        let mut value: u64 = 0;\n        for j in 0..8 {\n            value |= (arr_a[i*8+j] as u64) << ((56 - j*8) as u64);\n        }\n         combined_u64[i] = value;\n    }\n    for i in 4..8 {\n        let mut value: u64 = 0;\n        for j in 0..8 {\n            value |= (arr_b[(i-4)*8+j] as u64) << ((56 - j*8) as u64);\n        }\n         combined_u64[i] = value;\n    }\n\n    combined_u64\n}\n\nunconstrained\nfn u8_32s_to_u64_16_unconstrained(\n    arr_a: [u8; 32],\n    arr_b: [u8; 32],\n) -> [u64; 16] {\n    let mut combined_u64: [u64; 16] = [0; 16];\n    \n    for i in 0..4 {\n        let mut value: u64 = 0;\n        for j in 0..8 {\n            value |= (arr_a[i*8+j] as u64) << ((56 - j*8) as u64);\n        }\n         combined_u64[i] = value;\n    }\n    for i in 4..8 {\n        let mut value: u64 = 0;\n        for j in 0..8 {\n            value |= (arr_b[(i-4)*8+j] as u64) << ((56 - j*8) as u64);\n        }\n         combined_u64[i] = value;\n    }\n\n    combined_u64\n}\n\n#[test]\nfn test_u8_32s_to_u64_16() {\n    let arr_a: [u8; 32] = [\n        131,24,83,91,84,16,93,74,122,174,96,192,143,196,95,150,135,24,27,79,223,198,37,189,26,117,63,167,57,127,237,117\n    ];\n    let arr_b: [u8; 32] = [\n        53,71,241,28,168,105,102,70,242,243,172,176,142,49,1,106,250,194,62,99,12,93,17,245,159,97,254,245,123,13,42,165\n    ];\n    let out = u8_32s_to_u64_16(arr_a, arr_b);\n\n    assert(out[0] == 9446391870127103306);\n    assert(out[1] == 8840109498736861078);\n    assert(out[2] == 9734560624431998397);\n    assert(out[3] == 1906500004718046581);\n    assert(out[4] == 3839302312743495238);\n    assert(out[5] == 17506526050819047786);\n    assert(out[6] == 18069073250093961717);\n    assert(out[7] == 11484740855056378533);\n    assert(out[8] == 0);\n    assert(out[9] == 0);\n    assert(out[10] == 0);\n    assert(out[11] == 0);\n    assert(out[12] == 0);\n    assert(out[13] == 0);\n    assert(out[14] == 0);\n    assert(out[15] == 0);\n    // the above output is the hex \"0x8318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5\"\n}\n\nfn u8_32_to_u8_64(\n    arr_a: [u8; 32],\n    arr_b: [u8; 32],\n) -> [u8; 64] {\n    let mut combined: [u8; 64] = [0; 64];\n\n    for i in 0..32 {\n        combined[i] = arr_a[i];\n    }\n    for i in 0..32 {\n        combined[i + 32] = arr_b[i];\n    }\n\n    combined\n}\n\nunconstrained\nfn u8_32_to_u8_64_unconstrained(\n    arr_a: [u8; 32],\n    arr_b: [u8; 32],\n) -> [u8; 64] {\n    let mut combined: [u8; 64] = [0; 64];\n\n    for i in 0..32 {\n        combined[i] = arr_a[i];\n    }\n    for i in 0..32 {\n        combined[i + 32] = arr_b[i];\n    }\n\n    combined\n}\n\n\nfn u64_4_to_u8_32(\n    array: [u64; 4]\n) -> [u8; 32] {\n    let mut output: [u8; 32] = [0; 32];\n    let mut output_index = 0;\n\n    for num_idx in 0..4 {\n        for bit_pos in 0..8 {\n            let shift_amount: u64 = 56 - (bit_pos * 8) as u64;\n            output[output_index] = ((array[num_idx] >> shift_amount) & 255) as u8;\n            output_index += 1;\n        }\n    }\n\n    output\n}\n\nunconstrained\nfn u64_4_to_u8_32_unconstrained(\n    array: [u64; 4]\n) -> [u8; 32] {\n    let mut output: [u8; 32] = [0; 32];\n    let mut output_index = 0;\n\n    for num_idx in 0..4 {\n        for bit_pos in 0..8 {\n            let shift_amount: u64 = 56 - (bit_pos * 8) as u64;\n            output[output_index] = ((array[num_idx] >> shift_amount) & 255) as u8;\n            output_index += 1;\n        }\n    }\n\n    output\n}\n\n#[test]\nfn test_u64_4_to_u8_32() {\n    let hash: [u64; 4] = [\n        999647796417551690,\n        8840109498736861078,\n        9734560624431998397,\n        1906500004718046581\n    ];\n \n    let arr_out = u64_4_to_u8_32(hash);\n\n    assert(arr_out[0] == 13);\n    assert(arr_out[1] == 223);\n    assert(arr_out[2] == 118);\n    assert(arr_out[3] == 95);\n    assert(arr_out[4] == 221);\n    assert(arr_out[5] == 248);\n    assert(arr_out[6] == 93);\n    assert(arr_out[7] == 74);\n    assert(arr_out[8] == 122);\n    assert(arr_out[9] == 174);\n    assert(arr_out[10] == 96);\n    assert(arr_out[11] == 192);\n    assert(arr_out[12] == 143);\n    assert(arr_out[13] == 196);\n    assert(arr_out[14] == 95);\n    assert(arr_out[15] == 150);\n    assert(arr_out[16] == 135);\n    assert(arr_out[17] == 24);\n    assert(arr_out[18] == 27);\n    assert(arr_out[19] == 79);\n    assert(arr_out[20] == 223);\n    assert(arr_out[21] == 198);\n    assert(arr_out[22] == 37);\n    assert(arr_out[23] == 189);\n    assert(arr_out[24] == 26);\n    assert(arr_out[25] == 117);\n    assert(arr_out[26] == 63);\n    assert(arr_out[27] == 167);\n    assert(arr_out[28] == 57);\n    assert(arr_out[29] == 127);\n    assert(arr_out[30] == 237);\n    assert(arr_out[31] == 117);\n}\n\n/// @dev this method is used to convert a u8 array to a u160 (which is not supported by Noir, so it's represented as a Field)\n/// @dev will throw on Field overflow\nfn u8_to_u160(\n    array: [u8]\n) -> Field {\n    let mut addr: Field = 0;\n\n    for i in 0..20 {\n        // only take the last 20 bytes of the hash\n        addr = (addr * 256) + (array[i] as Field);\n    }\n\n    addr\n}\n\nunconstrained\nfn u8_to_u160_unconstrained(\n    array: [u8]\n) -> Field {\n    let mut addr: Field = 0;\n\n    for i in 0..20 {\n        // only take the last 20 bytes of the hash\n        addr = (addr * 256) + (array[i] as Field);\n    }\n\n    addr\n}\n\nfn u8_to_eth_address(\n    array: [u8]\n) -> Field {\n    u8_to_u160(array)\n}\n\nunconstrained\nfn u8_to_eth_address_unconstrained(\n    array: [u8]\n) -> Field {\n    u8_to_u160(array)\n}\n\n#[test]\nfn test_u8_32_to_u160() {\n    // keccak hash of hardhat 0 address pub key (0xc1ffd3cfee2d9e5cd67643f8f39fd6e51aad88f6f4ce6ab8827279cfffb92266) as u8 array\n    let hashed_pub_key = [\n        193,255,211,207,238,45,158,92,214,118,67,248,243,159,214,229,26,173,136,246,244,206,106,184,130,114,121,207,255,185,34,102\n    ];\n\n    let mut right_20_bytes: [u8] = [0; 20];\n    for i in 0..20 {\n        right_20_bytes[i] = hashed_pub_key[i + 12];\n    }\n\n    let addr = u8_to_u160(right_20_bytes);\n    let addr_aliased = u8_to_eth_address(right_20_bytes);\n\n    assert(addr == addr_aliased);\n    assert(addr == 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266); // hardhat address 0\n}\n\nfn split_u8_64(\n    arr: [u8; 64]\n) -> ([u8; 32], [u8; 32]) {\n    let mut arr_a: [u8; 32] = [0; 32];\n    let mut arr_b: [u8; 32] = [0; 32];\n\n    for i in 0..32 {\n        arr_a[i] = arr[i];\n        arr_b[i] = arr[i + 32];\n    };\n\n    (arr_a, arr_b)\n}\n\nunconstrained\nfn split_u8_64_unconstrained(\n    arr: [u8; 64]\n) -> ([u8; 32], [u8; 32]) {\n    let mut arr_a: [u8; 32] = [0; 32];\n    let mut arr_b: [u8; 32] = [0; 32];\n\n    for i in 0..32 {\n        arr_a[i] = arr[i];\n        arr_b[i] = arr[i + 32];\n    };\n\n    (arr_a, arr_b)\n}\n\n#[test]\nfn test_split_u8_64() {\n    let u8_64 = [\n        193,255,211,207,238,45,158,92,214,118,67,248,243,159,214,229,26,173,136,246,244,206,106,184,130,114,121,207,255,185,34,102,\n        193,255,211,207,238,45,158,92,214,118,67,248,243,159,214,229,26,173,136,246,244,206,106,184,130,114,121,207,255,185,34,102\n    ];\n\n    let (arr_a, arr_b) = split_u8_64(u8_64);\n\n    for i in 0..32 {\n        assert(arr_a[i] == u8_64[i]);\n        assert(arr_b[i] == u8_64[i + 32]);\n    }\n}\n",
      "path": "/Users/gabrielantonyxaviour/nargo/github.com/colinnielsen/noir-array-helpersv0.19.0/src/lib.nr"
    }
  }
}
