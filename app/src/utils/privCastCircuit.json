{
  "noir_version": "0.23.0+5be9f9d7e2f39ca228df10e5a530474af0331704",
  "hash": 17533690977142714456,
  "abi": {
    "parameters": [
      {
        "name": "signer_pub_x_key",
        "type": {
          "kind": "array",
          "length": 32,
          "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
        },
        "visibility": "private"
      },
      {
        "name": "signer_pub_y_key",
        "type": {
          "kind": "array",
          "length": 32,
          "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
        },
        "visibility": "private"
      },
      {
        "name": "signature",
        "type": {
          "kind": "array",
          "length": 64,
          "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
        },
        "visibility": "private"
      },
      {
        "name": "farcaster_id",
        "type": { "kind": "field" },
        "visibility": "private"
      },
      {
        "name": "vote_priv",
        "type": { "kind": "integer", "sign": "unsigned", "width": 8 },
        "visibility": "private"
      },
      {
        "name": "poll_id",
        "type": {
          "kind": "array",
          "length": 32,
          "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
        },
        "visibility": "public"
      },
      {
        "name": "vote",
        "type": { "kind": "integer", "sign": "unsigned", "width": 8 },
        "visibility": "public"
      },
      {
        "name": "nullifier",
        "type": {
          "kind": "array",
          "length": 32,
          "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
        },
        "visibility": "public"
      }
    ],
    "param_witnesses": {
      "farcaster_id": [{ "start": 128, "end": 129 }],
      "nullifier": [{ "start": 163, "end": 195 }],
      "poll_id": [{ "start": 130, "end": 162 }],
      "signature": [{ "start": 64, "end": 128 }],
      "signer_pub_x_key": [{ "start": 0, "end": 32 }],
      "signer_pub_y_key": [{ "start": 32, "end": 64 }],
      "vote": [{ "start": 162, "end": 163 }],
      "vote_priv": [{ "start": 129, "end": 130 }]
    },
    "return_type": {
      "abi_type": {
        "kind": "array",
        "length": 32,
        "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
      },
      "visibility": "public"
    },
    "return_witnesses": [
      163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177,
      178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192,
      193, 194
    ]
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "16": {
      "source": "mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n    \n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(_self: Self, _bit_size: u32) -> [u1] {}\n    \n    #[builtin(to_be_bits)]\n    fn __to_be_bits(_self: Self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(_self: Self, _bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(_self: Self, _radix: u32, _result_len: u32) -> [u8] {}\n    \n    #[builtin(to_be_radix)]\n    fn __to_be_radix(_self: Self, _radix: u32, _result_len: u32) -> [u8] {}\n\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x ∈ {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n}\n\n#[builtin(modulus_num_bits)]\npub fn modulus_num_bits() -> Field {}\n\n#[builtin(modulus_be_bits)]\npub fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub fn modulus_le_bytes() -> [u8] {}\n// Convert a 32 byte array to a field element\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n",
      "path": "std/field.nr"
    },
    "43": {
      "source": "use dep::std;\nuse dep::ecrecover;\n\nfn main(\n    signer_pub_x_key: [u8; 32],\n    signer_pub_y_key: [u8; 32],\n    signature: [u8; 64],\n    farcaster_id: Field,\n    vote_priv: u8,\n    poll_id: pub [u8; 32],\n    vote: pub u8,\n    nullifier: pub [u8; 32]\n) -> pub [u8; 32] {\n    // Compute hashed data\n    let hash_data: [u8; 32] = hash_nullifier(poll_id, farcaster_id.to_be_bytes(32));\n    // Ecreover signature and verify\n    let recoveredAddress: Field = ecrecover::ecrecover(signer_pub_x_key, signer_pub_y_key, signature, hash_data);\n    // Compute address from public key \n    let address: Field = address_from_pub_key(signer_pub_x_key, signer_pub_y_key);\n    // Check recovered address is computed address\n    assert(recoveredAddress == address);\n\n    // generate nullifier\n    let gen_nullifier = std::hash::keccak256(signature, 64);\n    // Check if nullifier hash is valid\n    assert(gen_nullifier == nullifier);\n\n    // Call oracle to get farcaster id\n    let fid: Field = get_farcaster_id(address);\n    // Check if farcaster id is valid\n    assert(fid as u8 != 0);\n    assert(fid == farcaster_id);\n\n    // Check if the vote is right\n    assert(vote == vote_priv);\n\n    // Return nullifier\n    nullifier\n}\n\nfn hash_nullifier(poll_id: [u8; 32], farcaster_id: [u8]) -> [u8; 32] {\n    let mut combined_key: [u8; 64] = [0; 64];\n    for i in 0..32 {\n        combined_key[i]=poll_id[i];\n    }\n    for i in 0..32 {\n        combined_key[i+32]=farcaster_id[i];\n    }\n\n    let hashed_message = std::hash::keccak256(combined_key, 64);\n    hashed_message\n}\n\nfn address_from_pub_key(pub_key_x: [u8; 32], pub_key_y: [u8; 32]) -> Field {\n    let mut combined_key: [u8; 64] = [0; 64];\n    for i in 0..64 {\n        if i as u8 < 32 {\n            combined_key[i]=pub_key_x[i];\n        } else {\n            combined_key[i]=pub_key_y[i as u8%32];\n        }\n    }\n    let hashed_key= std::hash::keccak256(combined_key, 64);\n    let mut generated_key: [u8]= [0; 20];\n    for i in 0..20 {\n        generated_key[i]=hashed_key[32-20+i];\n    }\n    u8_to_u160(generated_key)\n}\n\nfn u8_to_u160(array: [u8]) -> Field {\n    let mut addr: Field = 0;\n    for i in 0..20 {\n        // only take the last 20 bytes of the hash\n        addr = (addr * 256) + (array[i] as Field);\n    }\n    addr\n}\n\n#[oracle(getFid)]\nunconstrained fn farcaster_id(address: Field) -> Field {}\n\nunconstrained fn get_farcaster_id(address: Field) -> Field {\n    farcaster_id(address)\n}\n",
      "path": "/Users/gabrielantonyxaviour/Developer/projects/ongoing/priv.cast/circuits/src/main.nr"
    },
    "44": {
      "source": "use dep::std;\n \nmod secp256k1;\n\nfn ecrecover(\n    pub_key_x: [u8; 32],\n    pub_key_y: [u8; 32],\n    signature: [u8; 64], // clip v value\n    hashed_message: [u8; 32]\n) -> Field {\n    let key = secp256k1::PubKey::from_xy(pub_key_x, pub_key_y);\n\n    assert(key.verify_sig(signature, hashed_message));\n    let addr = key.to_eth_address();\n\n    addr\n}\n\n#[test]\nfn test_ecrecover() {\n    let pub_key_x = [131, 24, 83, 91, 84, 16, 93, 74, 122, 174, 96, 192, 143, 196, 95, 150, 135, 24, 27, 79, 223, 198, 37, 189, 26, 117, 63, 167, 57, 127, 237, 117];\n    let pub_key_y = [53, 71, 241, 28, 168, 105, 102, 70, 242, 243, 172, 176, 142, 49, 1, 106, 250, 194, 62, 99, 12, 93, 17, 245, 159, 97, 254, 245, 123, 13, 42, 165];\n    let signature = [57, 17, 112, 239, 241, 30, 64, 157, 170, 50, 85, 145, 156, 69, 226, 85, 147, 164, 10, 82, 71, 93, 42, 132, 200, 220, 161, 255, 95, 241, 211, 141, 81, 7, 150, 25, 25, 27, 162, 213, 80, 61, 12, 170, 50, 4, 154, 203, 252, 229, 119, 29, 202, 153, 50, 25, 126, 145, 245, 23, 136, 75, 29, 177];\n    let hashed_message = [13, 82, 120, 60, 76, 186, 215, 235, 175, 126, 185, 67, 252, 100, 143, 82, 130, 165, 32, 112, 68, 47, 193, 141, 141, 209, 109, 219, 47, 203, 175, 102];\n\n    let addr = ecrecover(pub_key_x, pub_key_y, signature, hashed_message);\n    assert(addr == 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266);\n}\n",
      "path": "/Users/gabrielantonyxaviour/nargo/github.com/colinnielsen/ecrecover-noirv0.19.0/src/lib.nr"
    },
    "45": {
      "source": "use dep::std;\n\nuse dep::array_helpers;\n\nstruct PubKey {\n    pub_x: [u8; 32],\n    pub_y: [u8; 32],\n}\n\nunconstrained\nfn split_uncompressed_pub_key(\n    pub_key: [u8; 65]\n) -> ([u8; 32], [u8; 32]) {\n    let mut pub_key_x: [u8; 32] = [0; 32];\n    let mut pub_key_y: [u8; 32] = [0; 32];\n\n    for i in 0..32 {\n        pub_key_x[i] = pub_key[i + 1];\n        pub_key_y[i] = pub_key[i + 32 + 1];\n    };\n\n    (pub_key_x, pub_key_y)\n}\n\nimpl PubKey {\n    fn from_xy(pub_x: [u8; 32], pub_y: [u8; 32]) -> PubKey {\n        PubKey {\n            pub_x,\n            pub_y,\n        }\n    }\n\n    fn from_unified(pub_key: [u8; 64]) -> PubKey {\n        let (key_x, key_y) = array_helpers::split_u8_64_unconstrained(pub_key);\n\n        PubKey {\n            pub_x: key_x,\n            pub_y: key_y,\n        }\n    }\n\n    fn from_uncompressed(pub_key: [u8; 65]) -> PubKey {\n        assert(pub_key[0] == 0x04);\n        let (key_x, key_y) = split_uncompressed_pub_key(pub_key);\n\n        PubKey {\n            pub_x: key_x,\n            pub_y: key_y,\n        }\n    }\n\n    fn verify_sig(self, signature: [u8; 64], hashed_message: [u8; 32]) -> bool {\n        std::ecdsa_secp256k1::verify_signature(self.pub_x, self.pub_y, signature, hashed_message)\n    }\n\n    fn to_eth_address(self) -> Field {\n        let pub_key = array_helpers::u8_32_to_u8_64_unconstrained(self.pub_x, self.pub_y);\n        let hashed_pub_key = std::hash::keccak256(pub_key, 64);\n\n        let mut addr: Field = 0;\n        for i in 0..20 {\n            // shift left by 8 and add the new value\n            addr = (addr * 256) + hashed_pub_key[i + 12] as Field;\n        }\n\n        addr\n    }\n\n    fn ecrecover(\n        self,\n        signature: [u8; 64],\n        hashed_message: [u8; 32]\n    ) -> Field {\n        assert(self.verify_sig(signature, hashed_message));\n\n        self.to_eth_address()\n    }\n}\n\n\n#[test]\nfn test_ecrecover_via_key() {\n    let pub_key_x = [131, 24, 83, 91, 84, 16, 93, 74, 122, 174, 96, 192, 143, 196, 95, 150, 135, 24, 27, 79, 223, 198, 37, 189, 26, 117, 63, 167, 57, 127, 237, 117];\n    let pub_key_y = [53, 71, 241, 28, 168, 105, 102, 70, 242, 243, 172, 176, 142, 49, 1, 106, 250, 194, 62, 99, 12, 93, 17, 245, 159, 97, 254, 245, 123, 13, 42, 165];\n    let signature = [57, 17, 112, 239, 241, 30, 64, 157, 170, 50, 85, 145, 156, 69, 226, 85, 147, 164, 10, 82, 71, 93, 42, 132, 200, 220, 161, 255, 95, 241, 211, 141, 81, 7, 150, 25, 25, 27, 162, 213, 80, 61, 12, 170, 50, 4, 154, 203, 252, 229, 119, 29, 202, 153, 50, 25, 126, 145, 245, 23, 136, 75, 29, 177];\n    let hashed_message = [13, 82, 120, 60, 76, 186, 215, 235, 175, 126, 185, 67, 252, 100, 143, 82, 130, 165, 32, 112, 68, 47, 193, 141, 141, 209, 109, 219, 47, 203, 175, 102];\n\n    let key = PubKey::from_xy(pub_key_x, pub_key_y);\n    assert(key.ecrecover(signature, hashed_message) == 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266);\n}\n",
      "path": "/Users/gabrielantonyxaviour/nargo/github.com/colinnielsen/ecrecover-noirv0.19.0/src/secp256k1.nr"
    },
    "46": {
      "source": "use dep::std;\n\nfn u8_32s_to_u64_16(\n    arr_a: [u8; 32],\n    arr_b: [u8; 32],\n) -> [u64; 16] {\n    let mut combined_u64: [u64; 16] = [0; 16];\n    \n    for i in 0..4 {\n        let mut value: u64 = 0;\n        for j in 0..8 {\n            value |= (arr_a[i*8+j] as u64) << ((56 - j*8) as u64);\n        }\n         combined_u64[i] = value;\n    }\n    for i in 4..8 {\n        let mut value: u64 = 0;\n        for j in 0..8 {\n            value |= (arr_b[(i-4)*8+j] as u64) << ((56 - j*8) as u64);\n        }\n         combined_u64[i] = value;\n    }\n\n    combined_u64\n}\n\nunconstrained\nfn u8_32s_to_u64_16_unconstrained(\n    arr_a: [u8; 32],\n    arr_b: [u8; 32],\n) -> [u64; 16] {\n    let mut combined_u64: [u64; 16] = [0; 16];\n    \n    for i in 0..4 {\n        let mut value: u64 = 0;\n        for j in 0..8 {\n            value |= (arr_a[i*8+j] as u64) << ((56 - j*8) as u64);\n        }\n         combined_u64[i] = value;\n    }\n    for i in 4..8 {\n        let mut value: u64 = 0;\n        for j in 0..8 {\n            value |= (arr_b[(i-4)*8+j] as u64) << ((56 - j*8) as u64);\n        }\n         combined_u64[i] = value;\n    }\n\n    combined_u64\n}\n\n#[test]\nfn test_u8_32s_to_u64_16() {\n    let arr_a: [u8; 32] = [\n        131,24,83,91,84,16,93,74,122,174,96,192,143,196,95,150,135,24,27,79,223,198,37,189,26,117,63,167,57,127,237,117\n    ];\n    let arr_b: [u8; 32] = [\n        53,71,241,28,168,105,102,70,242,243,172,176,142,49,1,106,250,194,62,99,12,93,17,245,159,97,254,245,123,13,42,165\n    ];\n    let out = u8_32s_to_u64_16(arr_a, arr_b);\n\n    assert(out[0] == 9446391870127103306);\n    assert(out[1] == 8840109498736861078);\n    assert(out[2] == 9734560624431998397);\n    assert(out[3] == 1906500004718046581);\n    assert(out[4] == 3839302312743495238);\n    assert(out[5] == 17506526050819047786);\n    assert(out[6] == 18069073250093961717);\n    assert(out[7] == 11484740855056378533);\n    assert(out[8] == 0);\n    assert(out[9] == 0);\n    assert(out[10] == 0);\n    assert(out[11] == 0);\n    assert(out[12] == 0);\n    assert(out[13] == 0);\n    assert(out[14] == 0);\n    assert(out[15] == 0);\n    // the above output is the hex \"0x8318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5\"\n}\n\nfn u8_32_to_u8_64(\n    arr_a: [u8; 32],\n    arr_b: [u8; 32],\n) -> [u8; 64] {\n    let mut combined: [u8; 64] = [0; 64];\n\n    for i in 0..32 {\n        combined[i] = arr_a[i];\n    }\n    for i in 0..32 {\n        combined[i + 32] = arr_b[i];\n    }\n\n    combined\n}\n\nunconstrained\nfn u8_32_to_u8_64_unconstrained(\n    arr_a: [u8; 32],\n    arr_b: [u8; 32],\n) -> [u8; 64] {\n    let mut combined: [u8; 64] = [0; 64];\n\n    for i in 0..32 {\n        combined[i] = arr_a[i];\n    }\n    for i in 0..32 {\n        combined[i + 32] = arr_b[i];\n    }\n\n    combined\n}\n\n\nfn u64_4_to_u8_32(\n    array: [u64; 4]\n) -> [u8; 32] {\n    let mut output: [u8; 32] = [0; 32];\n    let mut output_index = 0;\n\n    for num_idx in 0..4 {\n        for bit_pos in 0..8 {\n            let shift_amount: u64 = 56 - (bit_pos * 8) as u64;\n            output[output_index] = ((array[num_idx] >> shift_amount) & 255) as u8;\n            output_index += 1;\n        }\n    }\n\n    output\n}\n\nunconstrained\nfn u64_4_to_u8_32_unconstrained(\n    array: [u64; 4]\n) -> [u8; 32] {\n    let mut output: [u8; 32] = [0; 32];\n    let mut output_index = 0;\n\n    for num_idx in 0..4 {\n        for bit_pos in 0..8 {\n            let shift_amount: u64 = 56 - (bit_pos * 8) as u64;\n            output[output_index] = ((array[num_idx] >> shift_amount) & 255) as u8;\n            output_index += 1;\n        }\n    }\n\n    output\n}\n\n#[test]\nfn test_u64_4_to_u8_32() {\n    let hash: [u64; 4] = [\n        999647796417551690,\n        8840109498736861078,\n        9734560624431998397,\n        1906500004718046581\n    ];\n \n    let arr_out = u64_4_to_u8_32(hash);\n\n    assert(arr_out[0] == 13);\n    assert(arr_out[1] == 223);\n    assert(arr_out[2] == 118);\n    assert(arr_out[3] == 95);\n    assert(arr_out[4] == 221);\n    assert(arr_out[5] == 248);\n    assert(arr_out[6] == 93);\n    assert(arr_out[7] == 74);\n    assert(arr_out[8] == 122);\n    assert(arr_out[9] == 174);\n    assert(arr_out[10] == 96);\n    assert(arr_out[11] == 192);\n    assert(arr_out[12] == 143);\n    assert(arr_out[13] == 196);\n    assert(arr_out[14] == 95);\n    assert(arr_out[15] == 150);\n    assert(arr_out[16] == 135);\n    assert(arr_out[17] == 24);\n    assert(arr_out[18] == 27);\n    assert(arr_out[19] == 79);\n    assert(arr_out[20] == 223);\n    assert(arr_out[21] == 198);\n    assert(arr_out[22] == 37);\n    assert(arr_out[23] == 189);\n    assert(arr_out[24] == 26);\n    assert(arr_out[25] == 117);\n    assert(arr_out[26] == 63);\n    assert(arr_out[27] == 167);\n    assert(arr_out[28] == 57);\n    assert(arr_out[29] == 127);\n    assert(arr_out[30] == 237);\n    assert(arr_out[31] == 117);\n}\n\n/// @dev this method is used to convert a u8 array to a u160 (which is not supported by Noir, so it's represented as a Field)\n/// @dev will throw on Field overflow\nfn u8_to_u160(\n    array: [u8]\n) -> Field {\n    let mut addr: Field = 0;\n\n    for i in 0..20 {\n        // only take the last 20 bytes of the hash\n        addr = (addr * 256) + (array[i] as Field);\n    }\n\n    addr\n}\n\nunconstrained\nfn u8_to_u160_unconstrained(\n    array: [u8]\n) -> Field {\n    let mut addr: Field = 0;\n\n    for i in 0..20 {\n        // only take the last 20 bytes of the hash\n        addr = (addr * 256) + (array[i] as Field);\n    }\n\n    addr\n}\n\nfn u8_to_eth_address(\n    array: [u8]\n) -> Field {\n    u8_to_u160(array)\n}\n\nunconstrained\nfn u8_to_eth_address_unconstrained(\n    array: [u8]\n) -> Field {\n    u8_to_u160(array)\n}\n\n#[test]\nfn test_u8_32_to_u160() {\n    // keccak hash of hardhat 0 address pub key (0xc1ffd3cfee2d9e5cd67643f8f39fd6e51aad88f6f4ce6ab8827279cfffb92266) as u8 array\n    let hashed_pub_key = [\n        193,255,211,207,238,45,158,92,214,118,67,248,243,159,214,229,26,173,136,246,244,206,106,184,130,114,121,207,255,185,34,102\n    ];\n\n    let mut right_20_bytes: [u8] = [0; 20];\n    for i in 0..20 {\n        right_20_bytes[i] = hashed_pub_key[i + 12];\n    }\n\n    let addr = u8_to_u160(right_20_bytes);\n    let addr_aliased = u8_to_eth_address(right_20_bytes);\n\n    assert(addr == addr_aliased);\n    assert(addr == 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266); // hardhat address 0\n}\n\nfn split_u8_64(\n    arr: [u8; 64]\n) -> ([u8; 32], [u8; 32]) {\n    let mut arr_a: [u8; 32] = [0; 32];\n    let mut arr_b: [u8; 32] = [0; 32];\n\n    for i in 0..32 {\n        arr_a[i] = arr[i];\n        arr_b[i] = arr[i + 32];\n    };\n\n    (arr_a, arr_b)\n}\n\nunconstrained\nfn split_u8_64_unconstrained(\n    arr: [u8; 64]\n) -> ([u8; 32], [u8; 32]) {\n    let mut arr_a: [u8; 32] = [0; 32];\n    let mut arr_b: [u8; 32] = [0; 32];\n\n    for i in 0..32 {\n        arr_a[i] = arr[i];\n        arr_b[i] = arr[i + 32];\n    };\n\n    (arr_a, arr_b)\n}\n\n#[test]\nfn test_split_u8_64() {\n    let u8_64 = [\n        193,255,211,207,238,45,158,92,214,118,67,248,243,159,214,229,26,173,136,246,244,206,106,184,130,114,121,207,255,185,34,102,\n        193,255,211,207,238,45,158,92,214,118,67,248,243,159,214,229,26,173,136,246,244,206,106,184,130,114,121,207,255,185,34,102\n    ];\n\n    let (arr_a, arr_b) = split_u8_64(u8_64);\n\n    for i in 0..32 {\n        assert(arr_a[i] == u8_64[i]);\n        assert(arr_b[i] == u8_64[i + 32]);\n    }\n}\n",
      "path": "/Users/gabrielantonyxaviour/nargo/github.com/colinnielsen/noir-array-helpersv0.19.0/src/lib.nr"
    }
  }
}
