{"noir_version":"0.23.0+5be9f9d7e2f39ca228df10e5a530474af0331704","hash":9021785420247252686,"abi":{"parameters":[{"name":"signer_pub_x_key","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"signer_pub_y_key","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"signature","type":{"kind":"array","length":64,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"farcaster_id","type":{"kind":"field"},"visibility":"private"},{"name":"vote_priv","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"private"},{"name":"poll_id","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"nullifier","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"vote","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"public"}],"param_witnesses":{"farcaster_id":[{"start":128,"end":129}],"nullifier":[{"start":162,"end":194}],"poll_id":[{"start":130,"end":162}],"signature":[{"start":64,"end":128}],"signer_pub_x_key":[{"start":0,"end":32}],"signer_pub_y_key":[{"start":32,"end":64}],"vote":[{"start":194,"end":195}],"vote_priv":[{"start":129,"end":130}]},"return_type":{"abi_type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},"return_witnesses":[162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193]},"bytecode":"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","debug_symbols":"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","file_map":{"16":{"source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n    \n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(_self: Self, _bit_size: u32) -> [u1] {}\n    \n    #[builtin(to_be_bits)]\n    fn __to_be_bits(_self: Self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(_self: Self, _bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(_self: Self, _radix: u32, _result_len: u32) -> [u8] {}\n    \n    #[builtin(to_be_radix)]\n    fn __to_be_radix(_self: Self, _radix: u32, _result_len: u32) -> [u8] {}\n\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x ∈ {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n}\n\n#[builtin(modulus_num_bits)]\npub fn modulus_num_bits() -> Field {}\n\n#[builtin(modulus_be_bits)]\npub fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub fn modulus_le_bytes() -> [u8] {}\n// Convert a 32 byte array to a field element\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n","path":"std/field.nr"},"43":{"source":"use dep::std;\nuse dep::ecrecover;\n\nfn main(\n    signer_pub_x_key: [u8; 32],\n    signer_pub_y_key: [u8; 32],\n    signature: [u8; 64],\n    farcaster_id: Field,\n    vote_priv: u8,\n    poll_id: pub [u8; 32],\n    nullifier: pub [u8; 32],\n    vote: pub u8\n) -> pub [u8; 32] {\n    // Compute hashed data\n    let hash_data: [u8; 32] = hash_nullifier(poll_id, farcaster_id.to_be_bytes(32));\n    // Ecreover signature and verify\n    let recoveredAddress: Field = ecrecover::ecrecover(signer_pub_x_key, signer_pub_y_key, signature, hash_data);\n    // Compute address from public key \n    let address: Field = address_from_pub_key(signer_pub_x_key, signer_pub_y_key);\n    // Check recovered address is computed address\n    assert(recoveredAddress == address);\n\n    // generate nullifier\n    let gen_nullifier = std::hash::keccak256(signature, 64);\n    // Check if nullifier hash is valid\n    assert(gen_nullifier == nullifier);\n\n    // Call oracle to get farcaster id\n    let fid: Field = get_farcaster_id(address);\n    // Check if farcaster id is valid\n    assert(fid == farcaster_id);\n\n    // Check if the vote is right\n    assert(vote == vote_priv);\n\n    // Return nullifier\n    nullifier\n}\n\nfn hash_nullifier(poll_id: [u8; 32], farcaster_id: [u8]) -> [u8; 32] {\n    let mut combined_key: [u8; 64] = [0; 64];\n    for i in 0..32 {\n        combined_key[i]=poll_id[i];\n    }\n    for i in 0..32 {\n        combined_key[i+32]=farcaster_id[i];\n    }\n\n    let hashed_message = std::hash::keccak256(combined_key, 64);\n    hashed_message\n}\n\nfn address_from_pub_key(pub_key_x: [u8; 32], pub_key_y: [u8; 32]) -> Field {\n    let mut combined_key: [u8; 64] = [0; 64];\n    for i in 0..64 {\n        if i as u8 < 32 {\n            combined_key[i]=pub_key_x[i];\n        } else {\n            combined_key[i]=pub_key_y[i as u8%32];\n        }\n    }\n    let hashed_key= std::hash::keccak256(combined_key, 64);\n    let mut generated_key: [u8]= [0; 20];\n    for i in 0..20 {\n        generated_key[i]=hashed_key[32-20+i];\n    }\n    u8_to_u160(generated_key)\n}\n\nfn u8_to_u160(array: [u8]) -> Field {\n    let mut addr: Field = 0;\n    for i in 0..20 {\n        // only take the last 20 bytes of the hash\n        addr = (addr * 256) + (array[i] as Field);\n    }\n    addr\n}\n\n#[oracle(getFid)]\nunconstrained fn farcaster_id(address: Field) -> Field {}\n\nunconstrained fn get_farcaster_id(address: Field) -> Field {\n    farcaster_id(address)\n}\n","path":"/Users/gabrielantonyxaviour/Developer/projects/ongoing/priv.cast/circuits/src/main.nr"},"44":{"source":"use dep::std;\n \nmod secp256k1;\n\nfn ecrecover(\n    pub_key_x: [u8; 32],\n    pub_key_y: [u8; 32],\n    signature: [u8; 64], // clip v value\n    hashed_message: [u8; 32]\n) -> Field {\n    let key = secp256k1::PubKey::from_xy(pub_key_x, pub_key_y);\n\n    assert(key.verify_sig(signature, hashed_message));\n    let addr = key.to_eth_address();\n\n    addr\n}\n\n#[test]\nfn test_ecrecover() {\n    let pub_key_x = [131, 24, 83, 91, 84, 16, 93, 74, 122, 174, 96, 192, 143, 196, 95, 150, 135, 24, 27, 79, 223, 198, 37, 189, 26, 117, 63, 167, 57, 127, 237, 117];\n    let pub_key_y = [53, 71, 241, 28, 168, 105, 102, 70, 242, 243, 172, 176, 142, 49, 1, 106, 250, 194, 62, 99, 12, 93, 17, 245, 159, 97, 254, 245, 123, 13, 42, 165];\n    let signature = [57, 17, 112, 239, 241, 30, 64, 157, 170, 50, 85, 145, 156, 69, 226, 85, 147, 164, 10, 82, 71, 93, 42, 132, 200, 220, 161, 255, 95, 241, 211, 141, 81, 7, 150, 25, 25, 27, 162, 213, 80, 61, 12, 170, 50, 4, 154, 203, 252, 229, 119, 29, 202, 153, 50, 25, 126, 145, 245, 23, 136, 75, 29, 177];\n    let hashed_message = [13, 82, 120, 60, 76, 186, 215, 235, 175, 126, 185, 67, 252, 100, 143, 82, 130, 165, 32, 112, 68, 47, 193, 141, 141, 209, 109, 219, 47, 203, 175, 102];\n\n    let addr = ecrecover(pub_key_x, pub_key_y, signature, hashed_message);\n    assert(addr == 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266);\n}\n","path":"/Users/gabrielantonyxaviour/nargo/github.com/colinnielsen/ecrecover-noirv0.19.0/src/lib.nr"},"45":{"source":"use dep::std;\n\nuse dep::array_helpers;\n\nstruct PubKey {\n    pub_x: [u8; 32],\n    pub_y: [u8; 32],\n}\n\nunconstrained\nfn split_uncompressed_pub_key(\n    pub_key: [u8; 65]\n) -> ([u8; 32], [u8; 32]) {\n    let mut pub_key_x: [u8; 32] = [0; 32];\n    let mut pub_key_y: [u8; 32] = [0; 32];\n\n    for i in 0..32 {\n        pub_key_x[i] = pub_key[i + 1];\n        pub_key_y[i] = pub_key[i + 32 + 1];\n    };\n\n    (pub_key_x, pub_key_y)\n}\n\nimpl PubKey {\n    fn from_xy(pub_x: [u8; 32], pub_y: [u8; 32]) -> PubKey {\n        PubKey {\n            pub_x,\n            pub_y,\n        }\n    }\n\n    fn from_unified(pub_key: [u8; 64]) -> PubKey {\n        let (key_x, key_y) = array_helpers::split_u8_64_unconstrained(pub_key);\n\n        PubKey {\n            pub_x: key_x,\n            pub_y: key_y,\n        }\n    }\n\n    fn from_uncompressed(pub_key: [u8; 65]) -> PubKey {\n        assert(pub_key[0] == 0x04);\n        let (key_x, key_y) = split_uncompressed_pub_key(pub_key);\n\n        PubKey {\n            pub_x: key_x,\n            pub_y: key_y,\n        }\n    }\n\n    fn verify_sig(self, signature: [u8; 64], hashed_message: [u8; 32]) -> bool {\n        std::ecdsa_secp256k1::verify_signature(self.pub_x, self.pub_y, signature, hashed_message)\n    }\n\n    fn to_eth_address(self) -> Field {\n        let pub_key = array_helpers::u8_32_to_u8_64_unconstrained(self.pub_x, self.pub_y);\n        let hashed_pub_key = std::hash::keccak256(pub_key, 64);\n\n        let mut addr: Field = 0;\n        for i in 0..20 {\n            // shift left by 8 and add the new value\n            addr = (addr * 256) + hashed_pub_key[i + 12] as Field;\n        }\n\n        addr\n    }\n\n    fn ecrecover(\n        self,\n        signature: [u8; 64],\n        hashed_message: [u8; 32]\n    ) -> Field {\n        assert(self.verify_sig(signature, hashed_message));\n\n        self.to_eth_address()\n    }\n}\n\n\n#[test]\nfn test_ecrecover_via_key() {\n    let pub_key_x = [131, 24, 83, 91, 84, 16, 93, 74, 122, 174, 96, 192, 143, 196, 95, 150, 135, 24, 27, 79, 223, 198, 37, 189, 26, 117, 63, 167, 57, 127, 237, 117];\n    let pub_key_y = [53, 71, 241, 28, 168, 105, 102, 70, 242, 243, 172, 176, 142, 49, 1, 106, 250, 194, 62, 99, 12, 93, 17, 245, 159, 97, 254, 245, 123, 13, 42, 165];\n    let signature = [57, 17, 112, 239, 241, 30, 64, 157, 170, 50, 85, 145, 156, 69, 226, 85, 147, 164, 10, 82, 71, 93, 42, 132, 200, 220, 161, 255, 95, 241, 211, 141, 81, 7, 150, 25, 25, 27, 162, 213, 80, 61, 12, 170, 50, 4, 154, 203, 252, 229, 119, 29, 202, 153, 50, 25, 126, 145, 245, 23, 136, 75, 29, 177];\n    let hashed_message = [13, 82, 120, 60, 76, 186, 215, 235, 175, 126, 185, 67, 252, 100, 143, 82, 130, 165, 32, 112, 68, 47, 193, 141, 141, 209, 109, 219, 47, 203, 175, 102];\n\n    let key = PubKey::from_xy(pub_key_x, pub_key_y);\n    assert(key.ecrecover(signature, hashed_message) == 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266);\n}\n","path":"/Users/gabrielantonyxaviour/nargo/github.com/colinnielsen/ecrecover-noirv0.19.0/src/secp256k1.nr"},"46":{"source":"use dep::std;\n\nfn u8_32s_to_u64_16(\n    arr_a: [u8; 32],\n    arr_b: [u8; 32],\n) -> [u64; 16] {\n    let mut combined_u64: [u64; 16] = [0; 16];\n    \n    for i in 0..4 {\n        let mut value: u64 = 0;\n        for j in 0..8 {\n            value |= (arr_a[i*8+j] as u64) << ((56 - j*8) as u64);\n        }\n         combined_u64[i] = value;\n    }\n    for i in 4..8 {\n        let mut value: u64 = 0;\n        for j in 0..8 {\n            value |= (arr_b[(i-4)*8+j] as u64) << ((56 - j*8) as u64);\n        }\n         combined_u64[i] = value;\n    }\n\n    combined_u64\n}\n\nunconstrained\nfn u8_32s_to_u64_16_unconstrained(\n    arr_a: [u8; 32],\n    arr_b: [u8; 32],\n) -> [u64; 16] {\n    let mut combined_u64: [u64; 16] = [0; 16];\n    \n    for i in 0..4 {\n        let mut value: u64 = 0;\n        for j in 0..8 {\n            value |= (arr_a[i*8+j] as u64) << ((56 - j*8) as u64);\n        }\n         combined_u64[i] = value;\n    }\n    for i in 4..8 {\n        let mut value: u64 = 0;\n        for j in 0..8 {\n            value |= (arr_b[(i-4)*8+j] as u64) << ((56 - j*8) as u64);\n        }\n         combined_u64[i] = value;\n    }\n\n    combined_u64\n}\n\n#[test]\nfn test_u8_32s_to_u64_16() {\n    let arr_a: [u8; 32] = [\n        131,24,83,91,84,16,93,74,122,174,96,192,143,196,95,150,135,24,27,79,223,198,37,189,26,117,63,167,57,127,237,117\n    ];\n    let arr_b: [u8; 32] = [\n        53,71,241,28,168,105,102,70,242,243,172,176,142,49,1,106,250,194,62,99,12,93,17,245,159,97,254,245,123,13,42,165\n    ];\n    let out = u8_32s_to_u64_16(arr_a, arr_b);\n\n    assert(out[0] == 9446391870127103306);\n    assert(out[1] == 8840109498736861078);\n    assert(out[2] == 9734560624431998397);\n    assert(out[3] == 1906500004718046581);\n    assert(out[4] == 3839302312743495238);\n    assert(out[5] == 17506526050819047786);\n    assert(out[6] == 18069073250093961717);\n    assert(out[7] == 11484740855056378533);\n    assert(out[8] == 0);\n    assert(out[9] == 0);\n    assert(out[10] == 0);\n    assert(out[11] == 0);\n    assert(out[12] == 0);\n    assert(out[13] == 0);\n    assert(out[14] == 0);\n    assert(out[15] == 0);\n    // the above output is the hex \"0x8318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5\"\n}\n\nfn u8_32_to_u8_64(\n    arr_a: [u8; 32],\n    arr_b: [u8; 32],\n) -> [u8; 64] {\n    let mut combined: [u8; 64] = [0; 64];\n\n    for i in 0..32 {\n        combined[i] = arr_a[i];\n    }\n    for i in 0..32 {\n        combined[i + 32] = arr_b[i];\n    }\n\n    combined\n}\n\nunconstrained\nfn u8_32_to_u8_64_unconstrained(\n    arr_a: [u8; 32],\n    arr_b: [u8; 32],\n) -> [u8; 64] {\n    let mut combined: [u8; 64] = [0; 64];\n\n    for i in 0..32 {\n        combined[i] = arr_a[i];\n    }\n    for i in 0..32 {\n        combined[i + 32] = arr_b[i];\n    }\n\n    combined\n}\n\n\nfn u64_4_to_u8_32(\n    array: [u64; 4]\n) -> [u8; 32] {\n    let mut output: [u8; 32] = [0; 32];\n    let mut output_index = 0;\n\n    for num_idx in 0..4 {\n        for bit_pos in 0..8 {\n            let shift_amount: u64 = 56 - (bit_pos * 8) as u64;\n            output[output_index] = ((array[num_idx] >> shift_amount) & 255) as u8;\n            output_index += 1;\n        }\n    }\n\n    output\n}\n\nunconstrained\nfn u64_4_to_u8_32_unconstrained(\n    array: [u64; 4]\n) -> [u8; 32] {\n    let mut output: [u8; 32] = [0; 32];\n    let mut output_index = 0;\n\n    for num_idx in 0..4 {\n        for bit_pos in 0..8 {\n            let shift_amount: u64 = 56 - (bit_pos * 8) as u64;\n            output[output_index] = ((array[num_idx] >> shift_amount) & 255) as u8;\n            output_index += 1;\n        }\n    }\n\n    output\n}\n\n#[test]\nfn test_u64_4_to_u8_32() {\n    let hash: [u64; 4] = [\n        999647796417551690,\n        8840109498736861078,\n        9734560624431998397,\n        1906500004718046581\n    ];\n \n    let arr_out = u64_4_to_u8_32(hash);\n\n    assert(arr_out[0] == 13);\n    assert(arr_out[1] == 223);\n    assert(arr_out[2] == 118);\n    assert(arr_out[3] == 95);\n    assert(arr_out[4] == 221);\n    assert(arr_out[5] == 248);\n    assert(arr_out[6] == 93);\n    assert(arr_out[7] == 74);\n    assert(arr_out[8] == 122);\n    assert(arr_out[9] == 174);\n    assert(arr_out[10] == 96);\n    assert(arr_out[11] == 192);\n    assert(arr_out[12] == 143);\n    assert(arr_out[13] == 196);\n    assert(arr_out[14] == 95);\n    assert(arr_out[15] == 150);\n    assert(arr_out[16] == 135);\n    assert(arr_out[17] == 24);\n    assert(arr_out[18] == 27);\n    assert(arr_out[19] == 79);\n    assert(arr_out[20] == 223);\n    assert(arr_out[21] == 198);\n    assert(arr_out[22] == 37);\n    assert(arr_out[23] == 189);\n    assert(arr_out[24] == 26);\n    assert(arr_out[25] == 117);\n    assert(arr_out[26] == 63);\n    assert(arr_out[27] == 167);\n    assert(arr_out[28] == 57);\n    assert(arr_out[29] == 127);\n    assert(arr_out[30] == 237);\n    assert(arr_out[31] == 117);\n}\n\n/// @dev this method is used to convert a u8 array to a u160 (which is not supported by Noir, so it's represented as a Field)\n/// @dev will throw on Field overflow\nfn u8_to_u160(\n    array: [u8]\n) -> Field {\n    let mut addr: Field = 0;\n\n    for i in 0..20 {\n        // only take the last 20 bytes of the hash\n        addr = (addr * 256) + (array[i] as Field);\n    }\n\n    addr\n}\n\nunconstrained\nfn u8_to_u160_unconstrained(\n    array: [u8]\n) -> Field {\n    let mut addr: Field = 0;\n\n    for i in 0..20 {\n        // only take the last 20 bytes of the hash\n        addr = (addr * 256) + (array[i] as Field);\n    }\n\n    addr\n}\n\nfn u8_to_eth_address(\n    array: [u8]\n) -> Field {\n    u8_to_u160(array)\n}\n\nunconstrained\nfn u8_to_eth_address_unconstrained(\n    array: [u8]\n) -> Field {\n    u8_to_u160(array)\n}\n\n#[test]\nfn test_u8_32_to_u160() {\n    // keccak hash of hardhat 0 address pub key (0xc1ffd3cfee2d9e5cd67643f8f39fd6e51aad88f6f4ce6ab8827279cfffb92266) as u8 array\n    let hashed_pub_key = [\n        193,255,211,207,238,45,158,92,214,118,67,248,243,159,214,229,26,173,136,246,244,206,106,184,130,114,121,207,255,185,34,102\n    ];\n\n    let mut right_20_bytes: [u8] = [0; 20];\n    for i in 0..20 {\n        right_20_bytes[i] = hashed_pub_key[i + 12];\n    }\n\n    let addr = u8_to_u160(right_20_bytes);\n    let addr_aliased = u8_to_eth_address(right_20_bytes);\n\n    assert(addr == addr_aliased);\n    assert(addr == 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266); // hardhat address 0\n}\n\nfn split_u8_64(\n    arr: [u8; 64]\n) -> ([u8; 32], [u8; 32]) {\n    let mut arr_a: [u8; 32] = [0; 32];\n    let mut arr_b: [u8; 32] = [0; 32];\n\n    for i in 0..32 {\n        arr_a[i] = arr[i];\n        arr_b[i] = arr[i + 32];\n    };\n\n    (arr_a, arr_b)\n}\n\nunconstrained\nfn split_u8_64_unconstrained(\n    arr: [u8; 64]\n) -> ([u8; 32], [u8; 32]) {\n    let mut arr_a: [u8; 32] = [0; 32];\n    let mut arr_b: [u8; 32] = [0; 32];\n\n    for i in 0..32 {\n        arr_a[i] = arr[i];\n        arr_b[i] = arr[i + 32];\n    };\n\n    (arr_a, arr_b)\n}\n\n#[test]\nfn test_split_u8_64() {\n    let u8_64 = [\n        193,255,211,207,238,45,158,92,214,118,67,248,243,159,214,229,26,173,136,246,244,206,106,184,130,114,121,207,255,185,34,102,\n        193,255,211,207,238,45,158,92,214,118,67,248,243,159,214,229,26,173,136,246,244,206,106,184,130,114,121,207,255,185,34,102\n    ];\n\n    let (arr_a, arr_b) = split_u8_64(u8_64);\n\n    for i in 0..32 {\n        assert(arr_a[i] == u8_64[i]);\n        assert(arr_b[i] == u8_64[i + 32]);\n    }\n}\n","path":"/Users/gabrielantonyxaviour/nargo/github.com/colinnielsen/noir-array-helpersv0.19.0/src/lib.nr"}}}