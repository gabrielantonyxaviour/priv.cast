{
  "noir_version": "0.23.0+5be9f9d7e2f39ca228df10e5a530474af0331704",
  "hash": 2050329441972175862,
  "abi": {
    "parameters": [
      {
        "name": "signer_pub_x_key",
        "type": {
          "kind": "array",
          "length": 32,
          "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
        },
        "visibility": "private"
      },
      {
        "name": "signer_pub_y_key",
        "type": {
          "kind": "array",
          "length": 32,
          "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
        },
        "visibility": "private"
      },
      {
        "name": "signature",
        "type": {
          "kind": "array",
          "length": 64,
          "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
        },
        "visibility": "private"
      },
      {
        "name": "hashed_message",
        "type": {
          "kind": "array",
          "length": 32,
          "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
        },
        "visibility": "private"
      },
      {
        "name": "farcaster_id",
        "type": { "kind": "field" },
        "visibility": "private"
      },
      {
        "name": "vote_priv",
        "type": { "kind": "field" },
        "visibility": "private"
      },
      {
        "name": "poll_id",
        "type": {
          "kind": "array",
          "length": 32,
          "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
        },
        "visibility": "public"
      },
      { "name": "vote", "type": { "kind": "field" }, "visibility": "public" },
      {
        "name": "nullifier",
        "type": {
          "kind": "array",
          "length": 32,
          "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
        },
        "visibility": "public"
      }
    ],
    "param_witnesses": {
      "farcaster_id": [{ "start": 160, "end": 161 }],
      "hashed_message": [{ "start": 128, "end": 160 }],
      "nullifier": [{ "start": 195, "end": 227 }],
      "poll_id": [{ "start": 162, "end": 194 }],
      "signature": [{ "start": 64, "end": 128 }],
      "signer_pub_x_key": [{ "start": 0, "end": 32 }],
      "signer_pub_y_key": [{ "start": 32, "end": 64 }],
      "vote": [{ "start": 194, "end": 195 }],
      "vote_priv": [{ "start": 161, "end": 162 }]
    },
    "return_type": {
      "abi_type": {
        "kind": "array",
        "length": 32,
        "type": { "kind": "integer", "sign": "unsigned", "width": 8 }
      },
      "visibility": "public"
    },
    "return_witnesses": [
      195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209,
      210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224,
      225, 226
    ]
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "25": {
      "source": "mod hash;\nmod array;\nmod slice;\nmod merkle;\nmod schnorr;\nmod ecdsa_secp256k1;\nmod ecdsa_secp256r1;\nmod eddsa;\nmod grumpkin_scalar;\nmod grumpkin_scalar_mul;\nmod scalar_mul;\nmod sha256;\nmod sha512;\nmod field;\nmod ec;\nmod unsafe;\nmod collections;\nmod compat;\nmod option;\nmod string;\nmod test;\nmod cmp;\nmod ops;\nmod default;\nmod prelude;\nmod uint128;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(_with_newline: bool, _input: T) {}\n\nunconstrained pub fn print<T>(input: T) {\n    print_oracle(false, input);\n}\n\nunconstrained pub fn println<T>(input: T) {\n    print_oracle(true, input);\n}\n\n#[foreign(recursive_aggregation)]\npub fn verify_proof<N>(_verification_key: [Field], _proof: [Field], _public_inputs: [Field], _key_hash: Field) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(_x: T) {}\n// from_field and as_field are private since they are not valid for every type.\n// `as` should be the default for users to cast between primitive types, and in the future\n// traits can be used to work with generic types.\n#[builtin(from_field)]\nfn from_field<T>(_x: Field) -> T {}\n\n#[builtin(as_field)]\nfn as_field<T>(_x: T) -> Field {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T {\n    crate::from_field(crate::as_field(x) + crate::as_field(y))\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T {\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    crate::from_field(crate::as_field(x) + 340282366920938463463374607431768211456 - crate::as_field(y))\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T {\n    crate::from_field(crate::as_field(x) * crate::as_field(y))\n}\n",
      "path": "std/lib.nr"
    },
    "43": {
      "source": "use dep::std;\nuse dep::ecrecover;\n\nfn main(\n    signer_pub_x_key: [u8; 32],\n    signer_pub_y_key: [u8; 32],\n    signature: [u8; 64],\n    hashed_message: [u8; 32],\n    farcaster_id: Field,\n    vote_priv: Field,\n    poll_id: pub [u8; 32],\n    vote: pub Field,\n    nullifier: pub [u8; 32]\n) -> pub [u8; 32] {\n    // TOOD: eth-signed hash\n    // // let hash_data: [u8; 32] = get_hash_data(poll_id, farcaster_id.to_be_bytes(32));\n    // Compute address from public key\n    let computedAddress: Field = ecrecover::secp256k1::PubKey::from_xy(signer_pub_x_key, signer_pub_y_key).to_eth_address();\n    // Ecrecover signature and verify\n    let recoveredAddress = ecrecover::ecrecover(signer_pub_x_key, signer_pub_y_key, signature, hashed_message);\n    std::println(f\"Recovered address: {recoveredAddress}\");\n    // Check recovered address is computed address\n    assert(recoveredAddress == computedAddress);\n    // generate nullifier\n    let gen_nullifier = std::hash::keccak256(signature, 64);\n    // Check if nullifier hash is valid\n    assert(gen_nullifier == nullifier);\n    // Call oracle to get farcaster id\n    let fid: Field = get_farcaster_id(recoveredAddress);\n    // Check if farcaster id is valid\n    assert(fid != 0);\n    assert(fid == farcaster_id);\n    // Check if the vote is right\n    assert(vote as u8 == vote_priv as u8);\n    // Return nullifier\n    nullifier\n}\n\nfn get_hash_data(poll_id: [u8; 32], farcaster_id: [u8]) -> [u8; 32] {\n    let mut combined_key: [u8; 64] = [0; 64];\n    for i in 0..32 {\n        combined_key[i]=poll_id[i];\n    }\n    for i in 0..32 {\n        combined_key[i+32]=farcaster_id[i];\n    }\n\n    let hashed_message = std::hash::keccak256(combined_key, 64);\n    hashed_message\n}\n\nfn u8_to_u160(array: [u8]) -> Field {\n    let mut addr: Field = 0;\n    for i in 0..20 {\n        // only take the last 20 bytes of the hash\n        addr = (addr * 256) + (array[i] as Field);\n    }\n    addr\n}\n\n#[oracle(getFid)]\nunconstrained fn farcaster_id(address: Field) -> Field {}\n\nunconstrained fn get_farcaster_id(address: Field) -> Field {\n    farcaster_id(address)\n}\n",
      "path": "/Users/gabrielantonyxaviour/Developer/projects/ongoing/priv.cast/circuits/src/main.nr"
    },
    "44": {
      "source": "use dep::std;\n \nmod secp256k1;\n\nfn ecrecover(\n    pub_key_x: [u8; 32],\n    pub_key_y: [u8; 32],\n    signature: [u8; 64], // clip v value\n    hashed_message: [u8; 32]\n) -> Field {\n    let key = secp256k1::PubKey::from_xy(pub_key_x, pub_key_y);\n\n    assert(key.verify_sig(signature, hashed_message));\n    let addr = key.to_eth_address();\n\n    addr\n}\n\n#[test]\nfn test_ecrecover() {\n    let pub_key_x = [131, 24, 83, 91, 84, 16, 93, 74, 122, 174, 96, 192, 143, 196, 95, 150, 135, 24, 27, 79, 223, 198, 37, 189, 26, 117, 63, 167, 57, 127, 237, 117];\n    let pub_key_y = [53, 71, 241, 28, 168, 105, 102, 70, 242, 243, 172, 176, 142, 49, 1, 106, 250, 194, 62, 99, 12, 93, 17, 245, 159, 97, 254, 245, 123, 13, 42, 165];\n    let signature = [57, 17, 112, 239, 241, 30, 64, 157, 170, 50, 85, 145, 156, 69, 226, 85, 147, 164, 10, 82, 71, 93, 42, 132, 200, 220, 161, 255, 95, 241, 211, 141, 81, 7, 150, 25, 25, 27, 162, 213, 80, 61, 12, 170, 50, 4, 154, 203, 252, 229, 119, 29, 202, 153, 50, 25, 126, 145, 245, 23, 136, 75, 29, 177];\n    let hashed_message = [13, 82, 120, 60, 76, 186, 215, 235, 175, 126, 185, 67, 252, 100, 143, 82, 130, 165, 32, 112, 68, 47, 193, 141, 141, 209, 109, 219, 47, 203, 175, 102];\n\n    let addr = ecrecover(pub_key_x, pub_key_y, signature, hashed_message);\n    assert(addr == 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266);\n}\n",
      "path": "/Users/gabrielantonyxaviour/nargo/github.com/colinnielsen/ecrecover-noirv0.19.0/src/lib.nr"
    },
    "45": {
      "source": "use dep::std;\n\nuse dep::array_helpers;\n\nstruct PubKey {\n    pub_x: [u8; 32],\n    pub_y: [u8; 32],\n}\n\nunconstrained\nfn split_uncompressed_pub_key(\n    pub_key: [u8; 65]\n) -> ([u8; 32], [u8; 32]) {\n    let mut pub_key_x: [u8; 32] = [0; 32];\n    let mut pub_key_y: [u8; 32] = [0; 32];\n\n    for i in 0..32 {\n        pub_key_x[i] = pub_key[i + 1];\n        pub_key_y[i] = pub_key[i + 32 + 1];\n    };\n\n    (pub_key_x, pub_key_y)\n}\n\nimpl PubKey {\n    fn from_xy(pub_x: [u8; 32], pub_y: [u8; 32]) -> PubKey {\n        PubKey {\n            pub_x,\n            pub_y,\n        }\n    }\n\n    fn from_unified(pub_key: [u8; 64]) -> PubKey {\n        let (key_x, key_y) = array_helpers::split_u8_64_unconstrained(pub_key);\n\n        PubKey {\n            pub_x: key_x,\n            pub_y: key_y,\n        }\n    }\n\n    fn from_uncompressed(pub_key: [u8; 65]) -> PubKey {\n        assert(pub_key[0] == 0x04);\n        let (key_x, key_y) = split_uncompressed_pub_key(pub_key);\n\n        PubKey {\n            pub_x: key_x,\n            pub_y: key_y,\n        }\n    }\n\n    fn verify_sig(self, signature: [u8; 64], hashed_message: [u8; 32]) -> bool {\n        std::ecdsa_secp256k1::verify_signature(self.pub_x, self.pub_y, signature, hashed_message)\n    }\n\n    fn to_eth_address(self) -> Field {\n        let pub_key = array_helpers::u8_32_to_u8_64_unconstrained(self.pub_x, self.pub_y);\n        let hashed_pub_key = std::hash::keccak256(pub_key, 64);\n\n        let mut addr: Field = 0;\n        for i in 0..20 {\n            // shift left by 8 and add the new value\n            addr = (addr * 256) + hashed_pub_key[i + 12] as Field;\n        }\n\n        addr\n    }\n\n    fn ecrecover(\n        self,\n        signature: [u8; 64],\n        hashed_message: [u8; 32]\n    ) -> Field {\n        assert(self.verify_sig(signature, hashed_message));\n\n        self.to_eth_address()\n    }\n}\n\n\n#[test]\nfn test_ecrecover_via_key() {\n    let pub_key_x = [131, 24, 83, 91, 84, 16, 93, 74, 122, 174, 96, 192, 143, 196, 95, 150, 135, 24, 27, 79, 223, 198, 37, 189, 26, 117, 63, 167, 57, 127, 237, 117];\n    let pub_key_y = [53, 71, 241, 28, 168, 105, 102, 70, 242, 243, 172, 176, 142, 49, 1, 106, 250, 194, 62, 99, 12, 93, 17, 245, 159, 97, 254, 245, 123, 13, 42, 165];\n    let signature = [57, 17, 112, 239, 241, 30, 64, 157, 170, 50, 85, 145, 156, 69, 226, 85, 147, 164, 10, 82, 71, 93, 42, 132, 200, 220, 161, 255, 95, 241, 211, 141, 81, 7, 150, 25, 25, 27, 162, 213, 80, 61, 12, 170, 50, 4, 154, 203, 252, 229, 119, 29, 202, 153, 50, 25, 126, 145, 245, 23, 136, 75, 29, 177];\n    let hashed_message = [13, 82, 120, 60, 76, 186, 215, 235, 175, 126, 185, 67, 252, 100, 143, 82, 130, 165, 32, 112, 68, 47, 193, 141, 141, 209, 109, 219, 47, 203, 175, 102];\n\n    let key = PubKey::from_xy(pub_key_x, pub_key_y);\n    assert(key.ecrecover(signature, hashed_message) == 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266);\n}\n",
      "path": "/Users/gabrielantonyxaviour/nargo/github.com/colinnielsen/ecrecover-noirv0.19.0/src/secp256k1.nr"
    },
    "46": {
      "source": "use dep::std;\n\nfn u8_32s_to_u64_16(\n    arr_a: [u8; 32],\n    arr_b: [u8; 32],\n) -> [u64; 16] {\n    let mut combined_u64: [u64; 16] = [0; 16];\n    \n    for i in 0..4 {\n        let mut value: u64 = 0;\n        for j in 0..8 {\n            value |= (arr_a[i*8+j] as u64) << ((56 - j*8) as u64);\n        }\n         combined_u64[i] = value;\n    }\n    for i in 4..8 {\n        let mut value: u64 = 0;\n        for j in 0..8 {\n            value |= (arr_b[(i-4)*8+j] as u64) << ((56 - j*8) as u64);\n        }\n         combined_u64[i] = value;\n    }\n\n    combined_u64\n}\n\nunconstrained\nfn u8_32s_to_u64_16_unconstrained(\n    arr_a: [u8; 32],\n    arr_b: [u8; 32],\n) -> [u64; 16] {\n    let mut combined_u64: [u64; 16] = [0; 16];\n    \n    for i in 0..4 {\n        let mut value: u64 = 0;\n        for j in 0..8 {\n            value |= (arr_a[i*8+j] as u64) << ((56 - j*8) as u64);\n        }\n         combined_u64[i] = value;\n    }\n    for i in 4..8 {\n        let mut value: u64 = 0;\n        for j in 0..8 {\n            value |= (arr_b[(i-4)*8+j] as u64) << ((56 - j*8) as u64);\n        }\n         combined_u64[i] = value;\n    }\n\n    combined_u64\n}\n\n#[test]\nfn test_u8_32s_to_u64_16() {\n    let arr_a: [u8; 32] = [\n        131,24,83,91,84,16,93,74,122,174,96,192,143,196,95,150,135,24,27,79,223,198,37,189,26,117,63,167,57,127,237,117\n    ];\n    let arr_b: [u8; 32] = [\n        53,71,241,28,168,105,102,70,242,243,172,176,142,49,1,106,250,194,62,99,12,93,17,245,159,97,254,245,123,13,42,165\n    ];\n    let out = u8_32s_to_u64_16(arr_a, arr_b);\n\n    assert(out[0] == 9446391870127103306);\n    assert(out[1] == 8840109498736861078);\n    assert(out[2] == 9734560624431998397);\n    assert(out[3] == 1906500004718046581);\n    assert(out[4] == 3839302312743495238);\n    assert(out[5] == 17506526050819047786);\n    assert(out[6] == 18069073250093961717);\n    assert(out[7] == 11484740855056378533);\n    assert(out[8] == 0);\n    assert(out[9] == 0);\n    assert(out[10] == 0);\n    assert(out[11] == 0);\n    assert(out[12] == 0);\n    assert(out[13] == 0);\n    assert(out[14] == 0);\n    assert(out[15] == 0);\n    // the above output is the hex \"0x8318535b54105d4a7aae60c08fc45f9687181b4fdfc625bd1a753fa7397fed753547f11ca8696646f2f3acb08e31016afac23e630c5d11f59f61fef57b0d2aa5\"\n}\n\nfn u8_32_to_u8_64(\n    arr_a: [u8; 32],\n    arr_b: [u8; 32],\n) -> [u8; 64] {\n    let mut combined: [u8; 64] = [0; 64];\n\n    for i in 0..32 {\n        combined[i] = arr_a[i];\n    }\n    for i in 0..32 {\n        combined[i + 32] = arr_b[i];\n    }\n\n    combined\n}\n\nunconstrained\nfn u8_32_to_u8_64_unconstrained(\n    arr_a: [u8; 32],\n    arr_b: [u8; 32],\n) -> [u8; 64] {\n    let mut combined: [u8; 64] = [0; 64];\n\n    for i in 0..32 {\n        combined[i] = arr_a[i];\n    }\n    for i in 0..32 {\n        combined[i + 32] = arr_b[i];\n    }\n\n    combined\n}\n\n\nfn u64_4_to_u8_32(\n    array: [u64; 4]\n) -> [u8; 32] {\n    let mut output: [u8; 32] = [0; 32];\n    let mut output_index = 0;\n\n    for num_idx in 0..4 {\n        for bit_pos in 0..8 {\n            let shift_amount: u64 = 56 - (bit_pos * 8) as u64;\n            output[output_index] = ((array[num_idx] >> shift_amount) & 255) as u8;\n            output_index += 1;\n        }\n    }\n\n    output\n}\n\nunconstrained\nfn u64_4_to_u8_32_unconstrained(\n    array: [u64; 4]\n) -> [u8; 32] {\n    let mut output: [u8; 32] = [0; 32];\n    let mut output_index = 0;\n\n    for num_idx in 0..4 {\n        for bit_pos in 0..8 {\n            let shift_amount: u64 = 56 - (bit_pos * 8) as u64;\n            output[output_index] = ((array[num_idx] >> shift_amount) & 255) as u8;\n            output_index += 1;\n        }\n    }\n\n    output\n}\n\n#[test]\nfn test_u64_4_to_u8_32() {\n    let hash: [u64; 4] = [\n        999647796417551690,\n        8840109498736861078,\n        9734560624431998397,\n        1906500004718046581\n    ];\n \n    let arr_out = u64_4_to_u8_32(hash);\n\n    assert(arr_out[0] == 13);\n    assert(arr_out[1] == 223);\n    assert(arr_out[2] == 118);\n    assert(arr_out[3] == 95);\n    assert(arr_out[4] == 221);\n    assert(arr_out[5] == 248);\n    assert(arr_out[6] == 93);\n    assert(arr_out[7] == 74);\n    assert(arr_out[8] == 122);\n    assert(arr_out[9] == 174);\n    assert(arr_out[10] == 96);\n    assert(arr_out[11] == 192);\n    assert(arr_out[12] == 143);\n    assert(arr_out[13] == 196);\n    assert(arr_out[14] == 95);\n    assert(arr_out[15] == 150);\n    assert(arr_out[16] == 135);\n    assert(arr_out[17] == 24);\n    assert(arr_out[18] == 27);\n    assert(arr_out[19] == 79);\n    assert(arr_out[20] == 223);\n    assert(arr_out[21] == 198);\n    assert(arr_out[22] == 37);\n    assert(arr_out[23] == 189);\n    assert(arr_out[24] == 26);\n    assert(arr_out[25] == 117);\n    assert(arr_out[26] == 63);\n    assert(arr_out[27] == 167);\n    assert(arr_out[28] == 57);\n    assert(arr_out[29] == 127);\n    assert(arr_out[30] == 237);\n    assert(arr_out[31] == 117);\n}\n\n/// @dev this method is used to convert a u8 array to a u160 (which is not supported by Noir, so it's represented as a Field)\n/// @dev will throw on Field overflow\nfn u8_to_u160(\n    array: [u8]\n) -> Field {\n    let mut addr: Field = 0;\n\n    for i in 0..20 {\n        // only take the last 20 bytes of the hash\n        addr = (addr * 256) + (array[i] as Field);\n    }\n\n    addr\n}\n\nunconstrained\nfn u8_to_u160_unconstrained(\n    array: [u8]\n) -> Field {\n    let mut addr: Field = 0;\n\n    for i in 0..20 {\n        // only take the last 20 bytes of the hash\n        addr = (addr * 256) + (array[i] as Field);\n    }\n\n    addr\n}\n\nfn u8_to_eth_address(\n    array: [u8]\n) -> Field {\n    u8_to_u160(array)\n}\n\nunconstrained\nfn u8_to_eth_address_unconstrained(\n    array: [u8]\n) -> Field {\n    u8_to_u160(array)\n}\n\n#[test]\nfn test_u8_32_to_u160() {\n    // keccak hash of hardhat 0 address pub key (0xc1ffd3cfee2d9e5cd67643f8f39fd6e51aad88f6f4ce6ab8827279cfffb92266) as u8 array\n    let hashed_pub_key = [\n        193,255,211,207,238,45,158,92,214,118,67,248,243,159,214,229,26,173,136,246,244,206,106,184,130,114,121,207,255,185,34,102\n    ];\n\n    let mut right_20_bytes: [u8] = [0; 20];\n    for i in 0..20 {\n        right_20_bytes[i] = hashed_pub_key[i + 12];\n    }\n\n    let addr = u8_to_u160(right_20_bytes);\n    let addr_aliased = u8_to_eth_address(right_20_bytes);\n\n    assert(addr == addr_aliased);\n    assert(addr == 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266); // hardhat address 0\n}\n\nfn split_u8_64(\n    arr: [u8; 64]\n) -> ([u8; 32], [u8; 32]) {\n    let mut arr_a: [u8; 32] = [0; 32];\n    let mut arr_b: [u8; 32] = [0; 32];\n\n    for i in 0..32 {\n        arr_a[i] = arr[i];\n        arr_b[i] = arr[i + 32];\n    };\n\n    (arr_a, arr_b)\n}\n\nunconstrained\nfn split_u8_64_unconstrained(\n    arr: [u8; 64]\n) -> ([u8; 32], [u8; 32]) {\n    let mut arr_a: [u8; 32] = [0; 32];\n    let mut arr_b: [u8; 32] = [0; 32];\n\n    for i in 0..32 {\n        arr_a[i] = arr[i];\n        arr_b[i] = arr[i + 32];\n    };\n\n    (arr_a, arr_b)\n}\n\n#[test]\nfn test_split_u8_64() {\n    let u8_64 = [\n        193,255,211,207,238,45,158,92,214,118,67,248,243,159,214,229,26,173,136,246,244,206,106,184,130,114,121,207,255,185,34,102,\n        193,255,211,207,238,45,158,92,214,118,67,248,243,159,214,229,26,173,136,246,244,206,106,184,130,114,121,207,255,185,34,102\n    ];\n\n    let (arr_a, arr_b) = split_u8_64(u8_64);\n\n    for i in 0..32 {\n        assert(arr_a[i] == u8_64[i]);\n        assert(arr_b[i] == u8_64[i + 32]);\n    }\n}\n",
      "path": "/Users/gabrielantonyxaviour/nargo/github.com/colinnielsen/noir-array-helpersv0.19.0/src/lib.nr"
    }
  }
}
